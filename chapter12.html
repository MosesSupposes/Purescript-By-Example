<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canvas Graphics - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html" class="active"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="canvas-graphics"><a class="header" href="#canvas-graphics">Canvas Graphics</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>This chapter will be an extended example focussing on the <code>canvas</code> package, which provides a way to generate 2D graphics from PureScript using the HTML5 Canvas API.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>This module's project introduces the following new dependencies:</p>
<ul>
<li><code>canvas</code>, which gives types to methods from the HTML5 Canvas API</li>
<li><code>refs</code>, which provides a side-effect for using <em>global mutable references</em></li>
</ul>
<p>The source code for the chapter is broken up into a set of modules, each of which defines a <code>main</code> method. Different sections of this chapter are implemented in different files, and the <code>Main</code> module can be changed by modifying the Spago build command to run the appropriate file's <code>main</code> method at each point.</p>
<p>The HTML file <code>html/index.html</code> contains a single <code>canvas</code> element which will be used in each example, and a <code>script</code> element to load the compiled PureScript code. To test the code for each section, open the HTML file in your browser. Because most exercises target the browser, there are no unit tests for this chapter.</p>
<h2 id="simple-shapes"><a class="header" href="#simple-shapes">Simple Shapes</a></h2>
<p>The <code>Example/Rectangle.purs</code> file contains a simple introductory example, which draws a single blue rectangle at the center of the canvas. The module imports the <code>Effect</code> type from the <code>Effect</code> module, and also the <code>Graphics.Canvas</code> module, which contains actions in the <code>Effect</code> monad for working with the Canvas API.</p>
<p>The <code>main</code> action starts, like in the other modules, by using the <code>getCanvasElementById</code> action to get a reference to the canvas object, and the <code>getContext2D</code> action to access the 2D rendering context for the canvas:</p>
<p>The <code>void</code> function takes a functor and replaces its value with <code>Unit</code>. In the example it is used to make <code>main</code> conform with its signature.</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><em>Note</em>: the call to <code>unsafePartial</code> here is necessary since the pattern match on the result of <code>getCanvasElementById</code> is partial, matching only the <code>Just</code> constructor. For our purposes, this is fine, but in production code, we would probably want to match the <code>Nothing</code> constructor and provide an appropriate error message.</p>
<p>The types of these actions can be found using PSCi or by looking at the documentation:</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code> and <code>Context2D</code> are types defined in the <code>Graphics.Canvas</code> module. The same module also defines the <code>Canvas</code> effect, which is used by all of the actions in the module.</p>
<p>The graphics context <code>ctx</code> manages the state of the canvas, and provides methods to render primitive shapes, set styles and colors, and apply transformations.</p>
<p>We continue by setting the fill style to solid blue using the <code>setFillStyle</code> action. The longer hex notation of <code>#0000FF</code> may also be used for blue, but shorthand notation is easier for simple colors:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p>Note that the <code>setFillStyle</code> action takes the graphics context as an argument. This is a common pattern in the <code>Graphics.Canvas</code> module.</p>
<p>Finally, we use the <code>fillPath</code> action to fill the rectangle. <code>fillPath</code> has the following type:</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code> takes a graphics context and another action which builds the path to render. To build a path, we can use the <code>rect</code> action. <code>rect</code> takes a graphics context, and a record which provides the position and size of the rectangle:</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>Build the rectangle example, providing <code>Example.Rectangle</code> as the name of the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>Now, open the <code>html/index.html</code> file and verify that this code renders a blue rectangle in the center of the canvas.</p>
<h2 id="putting-row-polymorphism-to-work"><a class="header" href="#putting-row-polymorphism-to-work">Putting Row Polymorphism to Work</a></h2>
<p>There are other ways to render paths. The <code>arc</code> function renders an arc segment, and the <code>moveTo</code>, <code>lineTo</code> and <code>closePath</code> functions can be used to render piecewise-linear paths.</p>
<p>The <code>Shapes.purs</code> file renders three shapes: a rectangle, an arc segment and a triangle.</p>
<p>We have seen that the <code>rect</code> function takes a record as its argument. In fact, the properties of the rectangle are defined in a type synonym:</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p>The <code>x</code> and <code>y</code> properties represent the location of the top-left corner, while the <code>w</code> and <code>h</code> properties represent the width and height respectively.</p>
<p>To render an arc segment, we can use the <code>arc</code> function, passing a record with the following type:</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>Here, the <code>x</code> and <code>y</code> properties represent the center point, <code>r</code> is the radius, and <code>start</code> and <code>end</code> represent the endpoints of the arc in radians.</p>
<p>For example, this code fills an arc segment centered at <code>(300, 300)</code> with radius <code>50</code>. The arc completes 2/3rds of a rotation. Note that the unit circle is flipped vertically, since the y-axis increases towards the bottom of the canvas:</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p>Notice that both the <code>Rectangle</code> and <code>Arc</code> record types contain <code>x</code> and <code>y</code> properties of type <code>Number</code>. In both cases, this pair represents a point. This means that we can write row-polymorphic functions which can act on either type of record.</p>
<p>For example, the <code>Shapes</code> module defines a <code>translate</code> function which translates a shape by modifying its <code>x</code> and <code>y</code> properties:</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>Notice the row-polymorphic type. It says that <code>translate</code> accepts any record with <code>x</code> and <code>y</code> properties <em>and any other properties</em>, and returns the same type of record. The <code>x</code> and <code>y</code> fields are updated, but the rest of the fields remain unchanged.</p>
<p>This is an example of <em>record update syntax</em>. The expression <code>shape { ... }</code> creates a new record based on the <code>shape</code> record, with the fields inside the braces updated to the specified values. Note that the expressions inside the braces are separated from their labels by equals symbols, not colons like in record literals.</p>
<p>The <code>translate</code> function can be used with both the <code>Rectangle</code> and <code>Arc</code> records, as can be seen in the <code>Shapes</code> example.</p>
<p>The third type of path rendered in the <code>Shapes</code> example is a piecewise-linear path. Here is the corresponding code:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>There are three functions in use here:</p>
<ul>
<li><code>moveTo</code> moves the current location of the path to the specified coordinates,</li>
<li><code>lineTo</code> renders a line segment between the current location and the specified coordinates, and updates the current location,</li>
<li><code>closePath</code> completes the path by rendering a line segment joining the current location to the start position.</li>
</ul>
<p>The result of this code snippet is to fill an isosceles triangle.</p>
<p>Build the example by specifying <code>Example.Shapes</code> as the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>and open <code>html/index.html</code> again to see the result. You should see the three different types of shapes rendered to the canvas.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Experiment with the <code>strokePath</code> and <code>setStrokeStyle</code> functions in each of the examples so far.</p>
</li>
<li>
<p>(Easy) The <code>fillPath</code> and <code>strokePath</code> functions can be used to render complex paths with a common style by using a do notation block inside the function argument. Try changing the <code>Rectangle</code> example to render two rectangles side-by-side using the same call to <code>fillPath</code>. Try rendering a sector of a circle by using a combination of a piecewise-linear path and an arc segment.</p>
</li>
<li>
<p>(Medium) Given the following record type:</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>which represents a 2D point, write a function <code>renderPath</code> which strokes a closed path constructed from a number of points:</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>Given a function</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>which takes a <code>Number</code> between <code>0</code> and <code>1</code> as its argument and returns a <code>Point</code>, write an action which plots <code>f</code> by using your <code>renderPath</code> function. Your action should approximate the path by sampling <code>f</code> at a finite set of points.</p>
<p>Experiment by rendering different paths by varying the function <code>f</code>.</p>
</li>
</ol>
<h2 id="drawing-random-circles"><a class="header" href="#drawing-random-circles">Drawing Random Circles</a></h2>
<p>The <code>Example/Random.purs</code> file contains an example which uses the <code>Effect</code> monad to interleave two different types of side-effect: random number generation, and canvas manipulation. The example renders one hundred randomly generated circles onto the canvas.</p>
<p>The <code>main</code> action obtains a reference to the graphics context as before, and then sets the stroke and fill styles:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>Next, the code uses the <code>for_</code> function to loop over the integers between <code>0</code> and <code>100</code>:</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>On each iteration, the do notation block starts by generating three random numbers distributed between <code>0</code> and <code>1</code>. These numbers represent the <code>x</code> and <code>y</code> coordinates, and the radius of a circle:</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>Next, for each circle, the code creates an <code>Arc</code> based on these parameters and finally fills and strokes the arc with the current styles:</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x     : x * 600.0
         , y     : y * 600.0
         , radius: r * 50.0
         , start : 0.0
         , end   : Math.tau
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>Build this example by specifying the <code>Example.Random</code> module as the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p>and view the result by opening <code>html/index.html</code>.</p>
<h2 id="transformations"><a class="header" href="#transformations">Transformations</a></h2>
<p>There is more to the canvas than just rendering simple shapes. Every canvas maintains a transformation which is used to transform shapes before rendering. Shapes can be translated, rotated, scaled, and skewed.</p>
<p>The <code>canvas</code> library supports these transformations using the following functions:</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p>The <code>translate</code> action performs a translation whose components are specified by the properties of the <code>TranslateTransform</code> record.</p>
<p>The <code>rotate</code> action performs a rotation around the origin, through some number of radians specified by the first argument.</p>
<p>The <code>scale</code> action performs a scaling, with the origin as the center. The <code>ScaleTransform</code> record specifies the scale factors along the <code>x</code> and <code>y</code> axes.</p>
<p>Finally, <code>transform</code> is the most general action of the four here. It performs an affine transformation specified by a matrix.</p>
<p>Any shapes rendered after these actions have been invoked will automatically have the appropriate transformation applied.</p>
<p>In fact, the effect of each of these functions is to <em>post-multiply</em> the transformation with the context's current transformation. The result is that if multiple transformations applied after one another, then their effects are actually applied in reverse:</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>The effect of this sequence of actions is that the scene is rotated, then scaled, and finally translated.</p>
<h2 id="preserving-the-context"><a class="header" href="#preserving-the-context">Preserving the Context</a></h2>
<p>A common use case is to render some subset of the scene using a transformation, and then to reset the transformation afterwards.</p>
<p>The Canvas API provides the <code>save</code> and <code>restore</code> methods, which manipulate a <em>stack</em> of states associated with the canvas. <code>canvas</code> wraps this functionality into the following functions:</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p>The <code>save</code> action pushes the current state of the context (including the current transformation and any styles) onto the stack, and the <code>restore</code> action pops the top state from the stack and restores it.</p>
<p>This allows us to save the current state, apply some styles and transformations, render some primitives, and finally restore the original transformation and state. For example, the following function performs some canvas action, but applies a rotation before doing so, and restores the transformation afterwards:</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>In the interest of abstracting over common use cases using higher-order functions, the <code>canvas</code> library provides the <code>withContext</code> function, which performs some canvas action while preserving the original context state:</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p>We could rewrite the <code>rotated</code> function above using <code>withContext</code> as follows:</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="global-mutable-state"><a class="header" href="#global-mutable-state">Global Mutable State</a></h2>
<p>In this section, we'll use the <code>refs</code> package to demonstrate another effect in the <code>Effect</code> monad.</p>
<p>The <code>Effect.Ref</code> module provides a type constructor for global mutable references, and an associated effect:</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>A value of type <code>Ref a</code> is a mutable reference cell containing a value of type <code>a</code>, used to track global mutation. As such, it should be used sparingly.</p>
<p>The <code>Example/Refs.purs</code> file contains an example which uses a <code>Ref</code> to track mouse clicks on the <code>canvas</code> element.</p>
<p>The code starts by creating a new reference containing the value <code>0</code>, by using the <code>new</code> action:</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>Inside the click event handler, the <code>modify</code> action is used to update the click count, and the updated value is returned.</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p>In the <code>render</code> function, the click count is used to determine the transformation applied to a rectangle:</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Math.sin (toNumber count * Math.tau / 8.0) + 1.5
    let scaleY = Math.sin (toNumber count * Math.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Math.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>This action uses <code>withContext</code> to preserve the original transformation, and then applies the following sequence of transformations (remember that transformations are applied bottom-to-top):</p>
<ul>
<li>The rectangle is translated through <code>(-100, -100)</code> so that its center lies at the origin.</li>
<li>The rectangle is scaled around the origin.</li>
<li>The rectangle is rotated through some multiple of <code>10</code> degrees around the origin.</li>
<li>The rectangle is translated through <code>(300, 300)</code> so that it center lies at the center of the canvas.</li>
</ul>
<p>Build the example:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p>and open the <code>html/index.html</code> file. If you click the canvas repeatedly, you should see a green rectangle rotating around the center of the canvas.</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>(Easy) Write a higher-order function which strokes and fills a path simultaneously. Rewrite the <code>Random.purs</code> example using your function.</li>
<li>(Medium) Use <code>Random</code> and <code>Dom</code> to create an application which renders a circle with random position, color and radius to the canvas when the mouse is clicked.</li>
<li>(Medium) Write a function which transforms the scene by rotating it around a point with specified coordinates. <em>Hint</em>: use a translation to first translate the scene to the origin.</li>
</ol>
<h2 id="l-systems"><a class="header" href="#l-systems">L-Systems</a></h2>
<p>In this final example, we will use the <code>canvas</code> package to write a function for rendering <em>L-systems</em> (or <em>Lindenmayer systems</em>).</p>
<p>An L-system is defined by an <em>alphabet</em>, an initial sequence of letters from the alphabet, and a set of <em>production rules</em>. Each production rule takes a letter of the alphabet and returns a sequence of replacement letters. This process is iterated some number of times starting with the initial sequence of letters.</p>
<p>If each letter of the alphabet is associated with some instruction to perform on the canvas, the L-system can be rendered by following the instructions in order.</p>
<p>For example, suppose the alphabet consists of the letters <code>L</code> (turn left), <code>R</code> (turn right) and <code>F</code> (move forward). We might define the following production rules:</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>If we start with the initial sequence &quot;FRRFRRFRR&quot; and iterate, we obtain the following sequence:</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>and so on. Plotting a piecewise-linear path corresponding to this set of instruction approximates a curve called the <em>Koch curve</em>. Increasing the number of iterations increases the resolution of the curve.</p>
<p>Let's translate this into the language of types and functions.</p>
<p>We can represent our alphabet of letters with the following ADT:</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>This data type defines one data constructor for each letter in our alphabet.</p>
<p>How can we represent the initial sequence of letters? Well, that's just an array of letters from our alphabet, which we will call a <code>Sentence</code>:</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>Our production rules can be represented as a function from <code>Letter</code> to <code>Sentence</code> as follows:</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>This is just copied straight from the specification above.</p>
<p>Now we can implement a function <code>lsystem</code> which will take a specification in this form, and render it to the canvas. What type should <code>lsystem</code> have? Well, it needs to take values like <code>initial</code> and <code>productions</code> as arguments, as well as a function which can render a letter of the alphabet to the canvas.</p>
<p>Here is a first approximation to the type of <code>lsystem</code>:</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>The first two argument types correspond to the values <code>initial</code> and <code>productions</code>.</p>
<p>The third argument represents a function which takes a letter of the alphabet and <em>interprets</em> it by performing some actions on the canvas. In our example, this would mean turning left in the case of the letter <code>L</code>, turning right in the case of the letter <code>R</code>, and moving forward in the case of a letter <code>F</code>.</p>
<p>The final argument is a number representing the number of iterations of the production rules we would like to perform.</p>
<p>The first observation is that the <code>lsystem</code> function should work for only one type of <code>Letter</code>, but for any type, so we should generalize our type accordingly. Let's replace <code>Letter</code> and <code>Sentence</code> with <code>a</code> and <code>Array a</code> for some quantified type variable <code>a</code>:</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>The second observation is that, in order to implement instructions like &quot;turn left&quot; and &quot;turn right&quot;, we will need to maintain some state, namely the direction in which the path is moving at any time. We need to modify our function to pass the state through the computation. Again, the <code>lsystem</code> function should work for any type of state, so we will represent it using the type variable <code>s</code>.</p>
<p>We need to add the type <code>s</code> in three places:</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>Firstly, the type <code>s</code> was added as the type of an additional argument to <code>lsystem</code>. This argument will represent the initial state of the L-system.</p>
<p>The type <code>s</code> also appears as an argument to, and as the return type of the interpretation function (the third argument to <code>lsystem</code>). The interpretation function will now receive the current state of the L-system as an argument, and will return a new, updated state as its return value.</p>
<p>In the case of our example, we can define use following type to represent the state:</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>The properties <code>x</code> and <code>y</code> represent the current position of the path, and the <code>theta</code> property represents the current direction of the path, specified as the angle between the path direction and the horizontal axis, in radians.</p>
<p>The initial state of the system might be specified as follows:</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>Now let's try to implement the <code>lsystem</code> function. We will find that its definition is remarkably simple.</p>
<p>It seems reasonable that <code>lsystem</code> should recurse on its fourth argument (of type <code>Int</code>). On each step of the recursion, the current sentence will change, having been updated by using the production rules. With that in mind, let's begin by introducing names for the function arguments, and delegating to a helper function:</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p>The <code>go</code> function works by recursion on its second argument. There are two cases: when <code>n</code> is zero, and when <code>n</code> is non-zero.</p>
<p>In the first case, the recursion is complete, and we simply need to interpret the current sentence according to the interpretation function. We have a sentence of type <code>Array a</code>, a state of type <code>s</code>, and a function of type <code>s -&gt; a -&gt; Effect s</code>. This sounds like a job for the <code>foldM</code> function which we defined earlier, and which is available from the <code>control</code> package:</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>What about in the non-zero case? In that case, we can simply apply the production rules to each letter of the current sentence, concatenate the results, and repeat by calling <code>go</code> recursively:</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>That's it! Note how the use of higher order functions like <code>foldM</code> and <code>concatMap</code> allowed us to communicate our ideas concisely.</p>
<p>However, we're not quite done. The type we have given is actually still too specific. Note that we don't use any canvas operations anywhere in our implementation. Nor do we make use of the structure of the <code>Effect</code> monad at all. In fact, our function works for <em>any</em> monad <code>m</code>!</p>
<p>Here is the more general type of <code>lsystem</code>, as specified in the accompanying source code for this chapter:</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>We can understand this type as saying that our interpretation function is free to have any side-effects at all, captured by the monad <code>m</code>. It might render to the canvas, or print information to the console, or support failure or multiple return values. The reader is encouraged to try writing L-systems which use these various types of side-effect.</p>
<p>This function is a good example of the power of separating data from implementation. The advantage of this approach is that we gain the freedom to interpret our data in multiple different ways. We might even factor <code>lsystem</code> into two smaller functions: the first would build the sentence using repeated application of <code>concatMap</code>, and the second would interpret the sentence using <code>foldM</code>. This is also left as an exercise for the reader.</p>
<p>Let's complete our example by implementing its interpretation function. The type of <code>lsystem</code> tells us that its type signature must be <code>s -&gt; a -&gt; m s</code> for some types <code>a</code> and <code>s</code> and a type constructor <code>m</code>. We know that we want <code>a</code> to be <code>Letter</code> and <code>s</code> to be <code>State</code>, and for the monad <code>m</code> we can choose <code>Effect</code>. This gives us the following type:</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>To implement this function, we need to handle the three data constructors of the <code>Letter</code> type. To interpret the letters <code>L</code> (move left) and <code>R</code> (move right), we simply have to update the state to change the angle <code>theta</code> appropriately:</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Math.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Math.tau / 6.0 }
</code></pre>
<p>To interpret the letter <code>F</code> (move forward), we can calculate the new position of the path, render a line segment, and update the state, as follows:</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Math.cos state.theta * 1.5
          y = state.y + Math.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>Note that in the source code for this chapter, the <code>interpret</code> function is defined using a <code>let</code> binding inside the <code>main</code> function, so that the name <code>ctx</code> is in scope. It would also be possible to move the context into the <code>State</code> type, but this would be inappropriate because it is not a changing part of the state of the system.</p>
<p>To render this L-system, we can simply use the <code>strokePath</code> action:</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>Compile the L-system example using</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p>and open <code>html/index.html</code>. You should see the Koch curve rendered to the canvas.</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Modify the L-system example above to use <code>fillPath</code> instead of <code>strokePath</code>. <em>Hint</em>: you will need to include a call to <code>closePath</code>, and move the call to <code>moveTo</code> outside of the <code>interpret</code> function.</p>
</li>
<li>
<p>(Easy) Try changing the various numerical constants in the code, to understand their effect on the rendered system.</p>
</li>
<li>
<p>(Medium) Break the <code>lsystem</code> function into two smaller functions. The first should build the final sentence using repeated application of <code>concatMap</code>, and the second should use <code>foldM</code> to interpret the result.</p>
</li>
<li>
<p>(Medium) Add a drop shadow to the filled shape, by using the <code>setShadowOffsetX</code>, <code>setShadowOffsetY</code>, <code>setShadowBlur</code> and <code>setShadowColor</code> actions. <em>Hint</em>: use PSCi to find the types of these functions.</p>
</li>
<li>
<p>(Medium) The angle of the corners is currently a constant (<code>tau/6</code>). Instead, it can be moved into the <code>Letter</code> data type, which allows it to be changed by the production rules:</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>How can this new information be used in the production rules to create interesting shapes?</p>
</li>
<li>
<p>(Difficult) An L-system is given by an alphabet with four letters: <code>L</code> (turn left through 60 degrees), <code>R</code> (turn right through 60 degrees), <code>F</code> (move forward) and <code>M</code> (also move forward).</p>
<p>The initial sentence of the system is the single letter <code>M</code>.</p>
<p>The production rules are specified as follows:</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>Render this L-system. <em>Note</em>: you will need to decrease the number of iterations of the production rules, since the size of the final sentence grows exponentially with the number of iterations.</p>
<p>Now, notice the symmetry between <code>L</code> and <code>M</code> in the production rules. The two &quot;move forward&quot; instructions can be differentiated using a <code>Boolean</code> value using the following alphabet type:</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>Implement this L-system again using this representation of the alphabet.</p>
</li>
<li>
<p>(Difficult) Use a different monad <code>m</code> in the interpretation function. You might try using <code>Effect.Console</code> to write the L-system onto the console, or using <code>Effect.Random</code> to apply random &quot;mutations&quot; to the state type.</p>
</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we learned how to use the HTML5 Canvas API from PureScript by using the <code>canvas</code> library. We also saw a practical demonstration of many of the techniques we have learned already: maps and folds, records and row polymorphism, and the <code>Effect</code> monad for handling side-effects.</p>
<p>The examples also demonstrated the power of higher-order functions and <em>separating data from implementation</em>. It would be possible to extend these ideas to completely separate the representation of a scene from its rendering function, using an algebraic data type, for example:</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>This approach is taken in the <code>drawing</code> package, and it brings the flexibility of being able to manipulate the scene as data in various ways before rendering.</p>
<p>For examples of games rendered to the canvas, see the &quot;Behavior&quot; and &quot;Signal&quot; recipes in the <a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter11.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter13.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter11.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter13.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
