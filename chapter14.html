<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Domain-Specific Languages - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html" class="active"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="domain-specific-languages"><a class="header" href="#domain-specific-languages">Domain-Specific Languages</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>In this chapter, we will explore the implementation of <em>domain-specific languages</em> (or <em>DSLs</em>) in PureScript, using a number of standard techniques.</p>
<p>A domain-specific language is a language which is well-suited to development in a particular problem domain. Its syntax and functions are chosen to maximize readability of code used to express ideas in that domain. We have already seen a number of examples of domain-specific languages in this book:</p>
<ul>
<li>The <code>Game</code> monad and its associated actions, developed in chapter 11, constitute a domain-specific language for the domain of <em>text adventure game development</em>.</li>
<li>The <code>quickcheck</code> package, covered in chapter 13, is a domain-specific language for the domain of <em>generative testing</em>. Its combinators enable a particularly expressive notation for test properties.</li>
</ul>
<p>This chapter will take a more structured approach to some of standard techniques in the implementation of domain-specific languages. It is by no means a complete exposition of the subject, but should provide you with enough knowledge to build some practical DSLs for your own tasks.</p>
<p>Our running example will be a domain-specific language for creating HTML documents. Our aim will be to develop a type-safe language for describing correct HTML documents, and we will work by improving a naive implementation in small steps.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The project accompanying this chapter adds one new dependency - the <code>free</code> library, which defines the <em>free monad</em>, one of the tools which we will be using.</p>
<p>We will test this chapter's project in PSCi.</p>
<h2 id="a-html-data-type"><a class="header" href="#a-html-data-type">A HTML Data Type</a></h2>
<p>The most basic version of our HTML library is defined in the <code>Data.DOM.Simple</code> module. The module contains the following type definitions:</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Array Content)
  }

data Content
  = TextContent String
  | ElementContent Element

newtype Attribute = Attribute
  { key          :: String
  , value        :: String
  }
</code></pre>
<p>The <code>Element</code> type represents HTML elements. Each element consists of an element name, an array of attribute pairs and some content. The content property uses the <code>Maybe</code> type to indicate that an element might be open (containing other elements and text) or closed.</p>
<p>The key function of our library is a function</p>
<pre><code class="language-haskell">render :: Element -&gt; String
</code></pre>
<p>which renders HTML elements as HTML strings. We can try out this version of the library by constructing values of the appropriate types explicitly in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Simple
&gt; import Data.Maybe
&gt; import Effect.Console

&gt; :paste
… log $ render $ Element
…   { name: &quot;p&quot;
…   , attribs: [
…       Attribute
…         { key: &quot;class&quot;
…         , value: &quot;main&quot;
…         }
…     ]
…   , content: Just [
…       TextContent &quot;Hello World!&quot;
…     ]
…   }
… ^D

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>As it stands, there are several problems with this library:</p>
<ul>
<li>Creating HTML documents is difficult - every new element requires at least one record and one data constructor.</li>
<li>It is possible to represent invalid documents:
<ul>
<li>The developer might mistype the element name</li>
<li>The developer can associate an attribute with the wrong type of element</li>
<li>The developer can use a closed element when an open element is correct</li>
</ul>
</li>
</ul>
<p>In the remainder of the chapter, we will apply certain techniques to solve these problems and turn our library into a usable domain-specific language for creating HTML documents.</p>
<h2 id="smart-constructors"><a class="header" href="#smart-constructors">Smart Constructors</a></h2>
<p>The first technique we will apply is simple but can be very effective. Instead of exposing the representation of the data to the module's users, we can use the module exports list to hide the <code>Element</code>, <code>Content</code> and <code>Attribute</code> data constructors, and only export so-called <em>smart constructors</em>, which construct data which is known to be correct.</p>
<p>Here is an example. First, we provide a convenience function for creating HTML elements:</p>
<pre><code class="language-haskell">element :: String -&gt; Array Attribute -&gt; Maybe (Array Content) -&gt; Element
element name attribs content = Element
  { name:      name
  , attribs:   attribs
  , content:   content
  }
</code></pre>
<p>Next, we create smart constructors for those HTML elements we want our users to be able to create, by applying the <code>element</code> function:</p>
<pre><code class="language-haskell">a :: Array Attribute -&gt; Array Content -&gt; Element
a attribs content = element &quot;a&quot; attribs (Just content)

p :: Array Attribute -&gt; Array Content -&gt; Element
p attribs content = element &quot;p&quot; attribs (Just content)

img :: Array Attribute -&gt; Element
img attribs = element &quot;img&quot; attribs Nothing
</code></pre>
<p>Finally, we update the module exports list to only export those functions which are known to construct correct data structures:</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute(..)
  , Content(..)

  , a
  , p
  , img

  , render
  ) where
</code></pre>
<p>The module exports list is provided immediately after the module name inside parentheses. Each module export can be one of three types:</p>
<ul>
<li>A value (or function), indicated by the name of the value,</li>
<li>A type class, indicated by the name of the class,</li>
<li>A type constructor and any associated data constructors, indicated by the name of the type followed by a parenthesized list of exported data constructors.</li>
</ul>
<p>Here, we export the <code>Element</code> <em>type</em>, but we do not export its data constructors. If we did, the user would be able to construct invalid HTML elements.</p>
<p>In the case of the <code>Attribute</code> and <code>Content</code> types, we still export all of the data constructors (indicated by the symbol <code>..</code> in the exports list). We will apply the technique of smart constructors to these types shortly.</p>
<p>Notice that we have already made some big improvements to our library:</p>
<ul>
<li>It is impossible to represent HTML elements with invalid names (of course, we are restricted to the set of element names provided by the library).</li>
<li>Closed elements cannot contain content by construction.</li>
</ul>
<p>We can apply this technique to the <code>Content</code> type very easily. We simply remove the data constructors for the <code>Content</code> type from the exports list, and provide the following smart constructors:</p>
<pre><code class="language-haskell">text :: String -&gt; Content
text = TextContent

elem :: Element -&gt; Content
elem = ElementContent
</code></pre>
<p>Let's apply the same technique to the <code>Attribute</code> type. First, we provide a general-purpose smart constructor for attributes. Here is a first attempt:</p>
<pre><code class="language-haskell">attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute
  { key: key
  , value: value
  }

infix 4 attribute as :=
</code></pre>
<p>This representation suffers from the same problem as the original <code>Element</code> type - it is possible to represent attributes which do not exist or whose names were entered incorrectly. To solve this problem, we can create a newtype which represents attribute names:</p>
<pre><code class="language-haskell">newtype AttributeKey = AttributeKey String
</code></pre>
<p>With that, we can modify our operator as follows:</p>
<pre><code class="language-haskell">attribute :: AttributeKey -&gt; String -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: value
  }
</code></pre>
<p>If we do not export the <code>AttributeKey</code> data constructor, then the user has no way to construct values of type <code>AttributeKey</code> other than by using functions we explicitly export. Here are some examples:</p>
<pre><code class="language-haskell">href :: AttributeKey
href = AttributeKey &quot;href&quot;

_class :: AttributeKey
_class = AttributeKey &quot;class&quot;

src :: AttributeKey
src = AttributeKey &quot;src&quot;

width :: AttributeKey
width = AttributeKey &quot;width&quot;

height :: AttributeKey
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Here is the final exports list for our new module. Note that we no longer export any data constructors directly:</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute
  , Content
  , AttributeKey

  , a
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , attribute, (:=)
  , text
  , elem

  , render
  ) where
</code></pre>
<p>If we try this new module in PSCi, we can already see massive improvements in the conciseness of the user code:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Smart
&gt; import Effect.Console
&gt; log $ render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>Note, however, that no changes had to be made to the <code>render</code> function, because the underlying data representation never changed. This is one of the benefits of the smart constructors approach - it allows us to separate the internal data representation for a module from the representation which is perceived by users of its external API.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use the <code>Data.DOM.Smart</code> module to experiment by creating new HTML documents using <code>render</code>.</p>
</li>
<li>
<p>(Medium) Some HTML attributes such as <code>checked</code> and <code>disabled</code> do not require values, and may be rendered as <em>empty attributes</em>:</p>
<pre><code class="language-html">&lt;input disabled&gt;
</code></pre>
<p>Modify the representation of an <code>Attribute</code> to take empty attributes into account. Write a function which can be used in place of <code>attribute</code> or <code>:=</code> to add an empty attribute to an element.</p>
</li>
</ol>
<h2 id="phantom-types"><a class="header" href="#phantom-types">Phantom Types</a></h2>
<p>To motivate the next technique, consider the following code:</p>
<pre><code class="language-text">&gt; log $ render $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := &quot;foo&quot;
    , height := &quot;bar&quot;
    ]

&lt;img src=&quot;cat.jpg&quot; width=&quot;foo&quot; height=&quot;bar&quot; /&gt;
unit
</code></pre>
<p>The problem here is that we have provided string values for the <code>width</code> and <code>height</code> attributes, where we should only be allowed to provide numeric values in units of pixels or percentage points.</p>
<p>To solve this problem, we can introduce a so-called <em>phantom type</em> argument to our <code>AttributeKey</code> type:</p>
<pre><code class="language-haskell">newtype AttributeKey a = AttributeKey String
</code></pre>
<p>The type variable <code>a</code> is called a <em>phantom type</em> because there are no values of type <code>a</code> involved in the right-hand side of the definition. The type <code>a</code> only exists to provide more information at compile-time. Any value of type <code>AttributeKey a</code> is simply a string at runtime, but at compile-time, the type of the value tells us the desired type of the values associated with this key.</p>
<p>We can modify the type of our <code>attribute</code> function to take the new form of <code>AttributeKey</code> into account:</p>
<pre><code class="language-haskell">attribute :: forall a. IsValue a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: toValue value
  }
</code></pre>
<p>Here, the phantom type argument <code>a</code> is used to ensure that the attribute key and attribute value have compatible types. Since the user cannot create values of type <code>AttributeKey a</code> directly (only via the constants we provide in the library), every attribute will be correct by construction.</p>
<p>Note that the <code>IsValue</code> constraint ensures that whatever value type we associate to a key, its values can be converted to strings and displayed in the generated HTML. The <code>IsValue</code> type class is defined as follows:</p>
<pre><code class="language-haskell">class IsValue a where
  toValue :: a -&gt; String
</code></pre>
<p>We also provide type class instances for the <code>String</code> and <code>Int</code> types:</p>
<pre><code class="language-haskell">instance stringIsValue :: IsValue String where
  toValue = id

instance intIsValue :: IsValue Int where
  toValue = show
</code></pre>
<p>We also have to update our <code>AttributeKey</code> constants so that their types reflect the new type parameter:</p>
<pre><code class="language-haskell">href :: AttributeKey String
href = AttributeKey &quot;href&quot;

_class :: AttributeKey String
_class = AttributeKey &quot;class&quot;

src :: AttributeKey String
src = AttributeKey &quot;src&quot;

width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Now we find it is impossible to represent these invalid HTML documents, and we are forced to use numbers to represent the <code>width</code> and <code>height</code> attributes instead:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Phantom
&gt; import Effect.Console

&gt; :paste
… log $ render $ img
…   [ src    := &quot;cat.jpg&quot;
…   , width  := 100
…   , height := 200
…   ]
… ^D

&lt;img src=&quot;cat.jpg&quot; width=&quot;100&quot; height=&quot;200&quot; /&gt;
unit
</code></pre>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Create a data type which represents either pixel or percentage lengths. Write an instance of <code>IsValue</code> for your type. Modify the <code>width</code> and <code>height</code> attributes to use your new type.</p>
</li>
<li>
<p>(Difficult) By defining type-level representatives for the Boolean values <code>true</code> and <code>false</code>, we can use a phantom type to encode whether an <code>AttributeKey</code> represents an <em>empty attribute</em> such as <code>disabled</code> or <code>checked</code>.</p>
<pre><code class="language-haskell">data True
data False
</code></pre>
<p>Modify your solution to the previous exercise to use a phantom type to prevent the user from using the <code>attribute</code> operator with an empty attribute.</p>
</li>
</ol>
<h2 id="the-free-monad"><a class="header" href="#the-free-monad">The Free Monad</a></h2>
<p>In our final set of modifications to our API, we will use a construction called the <em>free monad</em> to turn our <code>Content</code> type into a monad, enabling do notation. This will allow us to structure our HTML documents in a form in which the nesting of elements becomes clearer - instead of this:</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ]
  [ elem $ img
      [ src    := &quot;cat.jpg&quot;
      , width  := 100
      , height := 200
      ]
  , text &quot;A cat&quot;
  ]
</code></pre>
<p>we will be able to write this:</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ] $ do
  elem $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := 100
    , height := 200
    ]
  text &quot;A cat&quot;
</code></pre>
<p>However, do notation is not the only benefit of a free monad. The free monad allows us to separate the <em>representation</em> of our monadic actions from their <em>interpretation</em>, and even support <em>multiple interpretations</em> of the same actions.</p>
<p>The <code>Free</code> monad is defined in the <code>free</code> library, in the <code>Control.Monad.Free</code> module. We can find out some basic information about it using PSCi, as follows:</p>
<pre><code class="language-text">&gt; import Control.Monad.Free

&gt; :kind Free
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>The kind of <code>Free</code> indicates that it takes a type constructor as an argument, and returns another type constructor. In fact, the <code>Free</code> monad can be used to turn any <code>Functor</code> into a <code>Monad</code>!</p>
<p>We begin by defining the <em>representation</em> of our monadic actions. To do this, we need to create a <code>Functor</code> with one data constructor for each monadic action we wish to support. In our case, our two monadic actions will be <code>elem</code> and <code>text</code>. In fact, we can simply modify our <code>Content</code> type as follows:</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a

instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
</code></pre>
<p>Here, the <code>ContentF</code> type constructor looks just like our old <code>Content</code> data type - however, it now takes a type argument <code>a</code>, and each data constructor has been modified to take a value of type <code>a</code> as an additional argument. The <code>Functor</code> instance simply applies the function <code>f</code> to the value of type <code>a</code> in each data constructor.</p>
<p>With that, we can define our new <code>Content</code> monad as a type synonym for the <code>Free</code> monad, which we construct by using our <code>ContentF</code> type constructor as the first type argument:</p>
<pre><code class="language-haskell">type Content = Free ContentF
</code></pre>
<p>Instead of a type synonym, we might use a <code>newtype</code> to avoid exposing the internal representation of our library to our users - by hiding the <code>Content</code> data constructor, we restrict our users to only using the monadic actions we provide.</p>
<p>Because <code>ContentF</code> is a <code>Functor</code>, we automatically get a <code>Monad</code> instance for <code>Free ContentF</code>.</p>
<p>We have to modify our <code>Element</code> data type slightly to take account of the new type argument on <code>Content</code>. We will simply require that the return type of our monadic computations be <code>Unit</code>:</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Content Unit)
  }
</code></pre>
<p>In addition, we have to modify our <code>elem</code> and <code>text</code> functions, which become our new monadic actions for the <code>Content</code> monad. To do this, we can use the <code>liftF</code> function, provided by the <code>Control.Monad.Free</code> module. Here is its type:</p>
<pre><code class="language-haskell">liftF :: forall f a. f a -&gt; Free f a
</code></pre>
<p><code>liftF</code> allows us to construct an action in our free monad from a value of type <code>f a</code> for some type <code>a</code>. In our case, we can simply use the data constructors of our <code>ContentF</code> type constructor directly:</p>
<pre><code class="language-haskell">text :: String -&gt; Content Unit
text s = liftF $ TextContent s unit

elem :: Element -&gt; Content Unit
elem e = liftF $ ElementContent e unit
</code></pre>
<p>Some other routine modifications have to be made, but the interesting changes are in the <code>render</code> function, where we have to <em>interpret</em> our free monad.</p>
<h2 id="interpreting-the-monad"><a class="header" href="#interpreting-the-monad">Interpreting the Monad</a></h2>
<p>The <code>Control.Monad.Free</code> module provides a number of functions for interpreting a computation in a free monad:</p>
<pre><code class="language-haskell">runFree
  :: forall f a
   . Functor f
  =&gt; (f (Free f a) -&gt; Free f a)
  -&gt; Free f a
  -&gt; a

runFreeM
  :: forall f m a
   . (Functor f, MonadRec m)
  =&gt; (f (Free f a) -&gt; m (Free f a))
  -&gt; Free f a
  -&gt; m a
</code></pre>
<p>The <code>runFree</code> function is used to compute a <em>pure</em> result. The <code>runFreeM</code> function allows us to use a monad to interpret the actions of our free monad.</p>
<p><em>Note</em>: Technically, we are restricted to using monads <code>m</code> which satisfy the stronger <code>MonadRec</code> constraint. In practice, this means that we don't need to worry about stack overflow, since <code>m</code> supports safe <em>monadic tail recursion</em>.</p>
<p>First, we have to choose a monad in which we can interpret our actions. We will use the <code>Writer String</code> monad to accumulate a HTML string as our result.</p>
<p>Our new <code>render</code> method starts by delegating to a helper function, <code>renderElement</code>, and using <code>execWriter</code> to run our computation in the <code>Writer</code> monad:</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render = execWriter &lt;&lt;&lt; renderElement
</code></pre>
<p><code>renderElement</code> is defined in a where block:</p>
<pre><code class="language-haskell">  where
    renderElement :: Element -&gt; Writer String Unit
    renderElement (Element e) = do
</code></pre>
<p>The definition of <code>renderElement</code> is straightforward, using the <code>tell</code> action from the <code>Writer</code> monad to accumulate several small strings:</p>
<pre><code class="language-haskell">      tell &quot;&lt;&quot;
      tell e.name
      for_ e.attribs $ \x -&gt; do
        tell &quot; &quot;
        renderAttribute x
      renderContent e.content
</code></pre>
<p>Next, we define the <code>renderAttribute</code> function, which is equally simple:</p>
<pre><code class="language-haskell">    where
      renderAttribute :: Attribute -&gt; Writer String Unit
      renderAttribute (Attribute x) = do
        tell x.key
        tell &quot;=\&quot;&quot;
        tell x.value
        tell &quot;\&quot;&quot;
</code></pre>
<p>The <code>renderContent</code> function is more interesting. Here, we use the <code>runFreeM</code> function to interpret the computation inside the free monad, delegating to a helper function, <code>renderContentItem</code>:</p>
<pre><code class="language-haskell">      renderContent :: Maybe (Content Unit) -&gt; Writer String Unit
      renderContent Nothing = tell &quot; /&gt;&quot;
      renderContent (Just content) = do
        tell &quot;&gt;&quot;
        runFreeM renderContentItem content
        tell &quot;&lt;/&quot;
        tell e.name
        tell &quot;&gt;&quot;
</code></pre>
<p>The type of <code>renderContentItem</code> can be deduced from the type signature of <code>runFreeM</code>. The functor <code>f</code> is our type constructor <code>ContentF</code>, and the monad <code>m</code> is the monad in which we are interpreting the computation, namely <code>Writer String</code>. This gives the following type signature for <code>renderContentItem</code>:</p>
<pre><code class="language-haskell">      renderContentItem :: ContentF (Content Unit) -&gt; Writer String (Content Unit)
</code></pre>
<p>We can implement this function by simply pattern matching on the two data constructors of <code>ContentF</code>:</p>
<pre><code class="language-haskell">      renderContentItem (TextContent s rest) = do
        tell s
        pure rest
      renderContentItem (ElementContent e rest) = do
        renderElement e
        pure rest
</code></pre>
<p>In each case, the expression <code>rest</code> has the type <code>Content Unit</code>, and represents the remainder of the interpreted computation. We can complete each case by returning the <code>rest</code> action.</p>
<p>That's it! We can test our new monadic API in PSCi, as follows:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Free
&gt; import Effect.Console

&gt; :paste
… log $ render $ p [] $ do
…   elem $ img [ src := &quot;cat.jpg&quot; ]
…   text &quot;A cat&quot;
… ^D

&lt;p&gt;&lt;img src=&quot;cat.jpg&quot; /&gt;A cat&lt;/p&gt;
unit
</code></pre>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>(Medium) Add a new data constructor to the <code>ContentF</code> type to support a new action <code>comment</code>, which renders a comment in the generated HTML. Implement the new action using <code>liftF</code>. Update the interpretation <code>renderContentItem</code> to interpret your new constructor appropriately.</li>
</ol>
<h2 id="extending-the-language"><a class="header" href="#extending-the-language">Extending the Language</a></h2>
<p>A monad in which every action returns something of type <code>Unit</code> is not particularly interesting. In fact, aside from an arguably nicer syntax, our monad adds no extra functionality over a <code>Monoid</code>.</p>
<p>Let's illustrate the power of the free monad construction by extending our language with a new monadic action which returns a non-trivial result.</p>
<p>Suppose we want to generate HTML documents which contain hyperlinks to different sections of the document using <em>anchors</em>. We can accomplish this already, by generating anchor names by hand and including them at least twice in the document: once at the definition of the anchor itself, and once in each hyperlink. However, this approach has some basic issues:</p>
<ul>
<li>The developer might fail to generate unique anchor names.</li>
<li>The developer might mistype one or more instances of the anchor name.</li>
</ul>
<p>In the interest of protecting the developer from their own mistakes, we can introduce a new type which represents anchor names, and provide a monadic action for generating new unique names.</p>
<p>The first step is to add a new type for names:</p>
<pre><code class="language-haskell">newtype Name = Name String

runName :: Name -&gt; String
runName (Name n) = n
</code></pre>
<p>Again, we define this as a newtype around <code>String</code>, but we must be careful not to export the data constructor in the module's export lists.</p>
<p>Next, we define an instance for the <code>IsValue</code> type class for our new type, so that we are able to use names in attribute values:</p>
<pre><code class="language-haskell">instance nameIsValue :: IsValue Name where
  toValue (Name n) = n
</code></pre>
<p>We also define a new data type for hyperlinks which can appear in <code>a</code> elements, as follows:</p>
<pre><code class="language-haskell">data Href
  = URLHref String
  | AnchorHref Name

instance hrefIsValue :: IsValue Href where
  toValue (URLHref url) = url
  toValue (AnchorHref (Name nm)) = &quot;#&quot; &lt;&gt; nm
</code></pre>
<p>With this new type, we can modify the value type of the <code>href</code> attribute, forcing our users to use our new <code>Href</code> type. We can also create a new <code>name</code> attribute, which can be used to turn an element into an anchor:</p>
<pre><code class="language-haskell">href :: AttributeKey Href
href = AttributeKey &quot;href&quot;

name :: AttributeKey Name
name = AttributeKey &quot;name&quot;
</code></pre>
<p>The remaining problem is that our users currently have no way to generate new names. We can provide this functionality in our <code>Content</code> monad. First, we need to add a new data constructor to our <code>ContentF</code> type constructor:</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a
  | NewName (Name -&gt; a)
</code></pre>
<p>The <code>NewName</code> data constructor corresponds to an action which returns a value of type <code>Name</code>. Notice that instead of requiring a <code>Name</code> as a data constructor argument, we require the user to provide a <em>function</em> of type <code>Name -&gt; a</code>. Remembering that the type <code>a</code> represents the <em>rest of the computation</em>, we can see that this function provides a way to continue computation after a value of type <code>Name</code> has been returned.</p>
<p>We also need to update the <code>Functor</code> instance for <code>ContentF</code>, taking into account the new data constructor, as follows:</p>
<pre><code class="language-haskell">instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
  map f (NewName k) = NewName (f &lt;&lt;&lt; k)
</code></pre>
<p>Now we can build our new action by using the <code>liftF</code> function, as before:</p>
<pre><code class="language-haskell">newName :: Content Name
newName = liftF $ NewName id
</code></pre>
<p>Notice that we provide the <code>id</code> function as our continuation, meaning that we return the result of type <code>Name</code> unchanged.</p>
<p>Finally, we need to update our interpretation function, to interpret the new action. We previously used the <code>Writer String</code> monad to interpret our computations, but that monad does not have the ability to generate new names, so we must switch to something else. The <code>WriterT</code> monad transformer can be used with the <code>State</code> monad to combine the effects we need. We can define our interpretation monad as a type synonym to keep our type signatures short:</p>
<pre><code class="language-haskell">type Interp = WriterT String (State Int)
</code></pre>
<p>Here, the state of type <code>Int</code> will act as an incrementing counter, used to generate unique names.</p>
<p>Because the <code>Writer</code> and <code>WriterT</code> monads use the same type class members to abstract their actions, we do not need to change any actions - we only need to replace every reference to <code>Writer String</code> with <code>Interp</code>. We do, however, need to modify the handler used to run our computation. Instead of just <code>execWriter</code>, we now need to use <code>evalState</code> as well:</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render e = evalState (execWriterT (renderElement e)) 0
</code></pre>
<p>We also need to add a new case to <code>renderContentItem</code>, to interpret the new <code>NewName</code> data constructor:</p>
<pre><code class="language-haskell">renderContentItem (NewName k) = do
  n &lt;- get
  let fresh = Name $ &quot;name&quot; &lt;&gt; show n
  put $ n + 1
  pure (k fresh)
</code></pre>
<p>Here, we are given a continuation <code>k</code> of type <code>Name -&gt; Content a</code>, and we need to construct an interpretation of type <code>Content a</code>. Our interpretation is simple: we use <code>get</code> to read the state, use that state to generate a unique name, then use <code>put</code> to increment the state. Finally, we pass our new name to the continuation to complete the computation.</p>
<p>With that, we can try out our new functionality in PSCi, by generating a unique name inside the <code>Content</code> monad, and using it as both the name of an element and the target of a hyperlink:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Name
&gt; import Effect.Console

&gt; :paste
… render $ p [ ] $ do
…   top &lt;- newName
…   elem $ a [ name := top ] $
…     text &quot;Top&quot;
…   elem $ a [ href := AnchorHref top ] $
…     text &quot;Back to top&quot;
… ^D

&lt;p&gt;&lt;a name=&quot;name0&quot;&gt;Top&lt;/a&gt;&lt;a href=&quot;#name0&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;
unit
</code></pre>
<p>You can verify that multiple calls to <code>newName</code> do in fact result in unique names.</p>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>
<p>(Medium) We can simplify the API further by hiding the <code>Element</code> type from its users. Make these changes in the following steps:</p>
<ul>
<li>Combine functions like <code>p</code> and <code>img</code> (with return type <code>Element</code>) with the <code>elem</code> action to create new actions with return type <code>Content Unit</code>.</li>
<li>Change the <code>render</code> function to accept an argument of type <code>Content Unit</code> instead of <code>Element</code>.</li>
</ul>
</li>
<li>
<p>(Medium) Hide the implementation of the <code>Content</code> monad by using a <code>newtype</code> instead of a type synonym. You should not export the data
constructor for your <code>newtype</code>.</p>
</li>
<li>
<p>(Difficult) Modify the <code>ContentF</code> type to support a new action</p>
<pre><code class="language-haskell">isMobile :: Content Boolean
</code></pre>
<p>which returns a boolean value indicating whether or not the document is being rendered for display on a mobile device.</p>
<p><em>Hint</em>: use the <code>ask</code> action and the <code>ReaderT</code> monad transformer to interpret this action. Alternatively, you might prefer to use the <code>RWS</code> monad.</p>
</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we developed a domain-specific language for creating HTML documents, by incrementally improving a naive implementation using some standard techniques:</p>
<ul>
<li>We used <em>smart constructors</em> to hide the details of our data representation, only permitting the user to create documents which were <em>correct-by-construction</em>.</li>
<li>We used an <em>user-defined infix binary operator</em> to improve the syntax of the language.</li>
<li>We used <em>phantom types</em> to encode additional information in the types of our data, preventing the user from providing attribute values of the wrong type.</li>
<li>We used the <em>free monad</em> to turn our array representation of a collection of content into a monadic representation supporting do notation. We then extended this representation to support a new monadic action, and interpreted the monadic computations using standard monad transformers.</li>
</ul>
<p>These techniques all leverage PureScript's module and type systems, either to prevent the user from making mistakes or to improve the syntax of the domain-specific language.</p>
<p>The implementation of domain-specific languages in functional programming languages is an area of active research, but hopefully this provides a useful introduction some simple techniques, and illustrates the power of working in a language with expressive types.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter13.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter13.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
