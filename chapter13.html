<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generative Testing - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html" class="active"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generative-testing"><a class="header" href="#generative-testing">Generative Testing</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>In this chapter, we will see a particularly elegant application of type classes to the problem of testing. Instead of testing our code by telling the compiler <em>how</em> to test, we simply assert <em>what</em> properties our code should have. Test cases can be generated randomly from this specification, using type classes to hide the boilerplate code of random data generation. This is called <em>generative testing</em> (or <em>property-based testing</em>), a technique made popular by the <a href="https://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a> library in Haskell.</p>
<p>The <code>quickcheck</code> package is a port of Haskell's QuickCheck library to PureScript, and for the most part, it preserves the types and syntax of the original library. We will see how to use <code>quickcheck</code> to test a simple library, using Spago to integrate our test suite into our development process.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>This chapter's project adds <code>quickcheck</code> as a dependency.</p>
<p>In a Spago project, test sources should be placed in the <code>test</code> directory, and the main module for the test suite should be named <code>Test.Main</code>. The test suite can be run using the <code>spago test</code> command.</p>
<h2 id="writing-properties"><a class="header" href="#writing-properties">Writing Properties</a></h2>
<p>The <code>Merge</code> module implements a simple function <code>merge</code>, which we will use to demonstrate the features of the <code>quickcheck</code> library.</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code> takes two sorted arrays of integers, and merges their elements so that the result is also sorted. For example:</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>In a typical test suite, we might test <code>merge</code> by generating a few small test cases like this by hand, and asserting that the results were equal to the appropriate values. However, everything we need to know about the <code>merge</code> function can be summarized by this property:</p>
<ul>
<li>If <code>xs</code> and <code>ys</code> are sorted, then <code>merge xs ys</code> is the sorted result of both arrays appended together.</li>
</ul>
<p><code>quickcheck</code> allows us to test this property directly, by generating random test cases. We simply state the properties that we want our code to have, as functions. In this case, we have a single property:</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>When we run this code, <code>quickcheck</code> will attempt to disprove the properties we claimed, by generating random inputs <code>xs</code> and <code>ys</code>, and passing them to our functions. If our function returns <code>false</code> for any inputs, the property will be incorrect, and the library will raise an error. Fortunately, the library is unable to disprove our properties after generating 100 random test cases:</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>If we deliberately introduce a bug into the <code>merge</code> function (for example, by changing the less-than check for a greater-than check), then an exception is thrown at runtime after the first failed test case:</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>As we can see, this error message is not very helpful, but it can be improved with a little work.</p>
<h2 id="improving-error-messages"><a class="header" href="#improving-error-messages">Improving Error Messages</a></h2>
<p>To provide error messages along with our failed test cases, <code>quickcheck</code> provides the <code>&lt;?&gt;</code> operator. Simply separate the property definition from the error message using <code>&lt;?&gt;</code>, as follows:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>This time, if we modify the code to introduce a bug, we see our improved error message after the first failed test case:</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>Notice how the input <code>xs</code> and <code>ys</code> were generated as arrays of randomly-selected integers.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>(Easy) Write a property which asserts that merging an array with the empty array does not modify the original array. <em>Note</em>: This new property is redundant, since this situation is already covered by our existing property. We're just trying to give you readers a simple way to practice using quickCheck.</li>
<li>(Easy) Add an appropriate error message to the remaining property for <code>merge</code>.</li>
</ol>
<h2 id="testing-polymorphic-code"><a class="header" href="#testing-polymorphic-code">Testing Polymorphic Code</a></h2>
<p>The <code>Merge</code> module defines a generalization of the <code>merge</code> function, called <code>mergePoly</code>, which works not only with arrays of numbers, but also arrays of any type belonging to the <code>Ord</code> type class:</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p>If we modify our original test to use <code>mergePoly</code> in place of <code>merge</code>, we see the following error message:</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>This error message indicates that the compiler could not generate random test cases, because it did not know what type of elements we wanted our arrays to have. In these sorts of cases, we can use type annotations to force the compiler to infer a particular type, such as <code>Array Int</code>:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>We can alternatively use a helper function to specify type, which may result in cleaner code. For example, if we define a function <code>ints</code> as a synonym for the identity function:</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>then we can modify our test so that the compiler infers the type <code>Array Int</code> for our two array arguments:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>Here, <code>xs</code> and <code>ys</code> both have type <code>Array Int</code>, since the <code>ints</code> function has been used to disambiguate the unknown type.</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>bools</code> which forces the types of <code>xs</code> and <code>ys</code> to be <code>Array Boolean</code>, and add additional properties which test <code>mergePoly</code> at that type.</li>
<li>(Medium) Choose a pure function from the core libraries (for example, from the <code>arrays</code> package), and write a QuickCheck property for it, including an appropriate error message. Your property should use a helper function to fix any polymorphic type arguments to either <code>Int</code> or <code>Boolean</code>.</li>
</ol>
<h2 id="generating-arbitrary-data"><a class="header" href="#generating-arbitrary-data">Generating Arbitrary Data</a></h2>
<p>Now we will see how the <code>quickcheck</code> library is able to randomly generate test cases for our properties.</p>
<p>Those types whose values can be randomly generated are captured by the <code>Arbitrary</code> type class:</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p>The <code>Gen</code> type constructor represents the side-effects of <em>deterministic random data generation</em>. It uses a pseudo-random number generator to generate deterministic random function arguments from a seed value. The <code>Test.QuickCheck.Gen</code> module defines several useful combinators for building generators.</p>
<p><code>Gen</code> is also a monad and an applicative functor, so we have the usual collection of combinators at our disposal for creating new instances of the <code>Arbitrary</code> type class.</p>
<p>For example, we can use the <code>Arbitrary</code> instance for the <code>Int</code> type, provided in the <code>quickcheck</code> library, to create a distribution on the 256 byte values, using the <code>Functor</code> instance for <code>Gen</code> to map a function from integers to bytes over arbitrary integer values:</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance arbitraryByte :: Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>Here, we define a type <code>Byte</code> of integral values between 0 and 255. The <code>Arbitrary</code> instance uses the <code>map</code> function to lift the <code>intToByte</code> function over the <code>arbitrary</code> action. The type of the inner <code>arbitrary</code> action is inferred as <code>Gen Int</code>.</p>
<p>We can also use this idea to improve our test for <code>merge</code>:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>In this test, we generated arbitrary arrays <code>xs</code> and <code>ys</code>, but had to sort them, since <code>merge</code> expects sorted input. On the other hand, we could create a newtype representing sorted arrays, and write an <code>Arbitrary</code> instance which generates sorted data:</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance arbSorted :: (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>With this type constructor, we can modify our test as follows:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>This may look like a small change, but the types of <code>xs</code> and <code>ys</code> have changed to <code>Sorted Int</code>, instead of just <code>Array Int</code>. This communicates our <em>intent</em> in a clearer way - the <code>mergePoly</code> function takes sorted input. Ideally, the type of the <code>mergePoly</code> function itself would be updated to use the <code>Sorted</code> type constructor.</p>
<p>As a more interesting example, the <code>Tree</code> module defines a type of sorted binary trees with values at the branches:</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p>The <code>Tree</code> module defines the following API:</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p>The <code>insert</code> function is used to insert a new element into a sorted tree, and the <code>member</code> function can be used to query a tree for a particular value. For example:</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p>The <code>toArray</code> and <code>fromArray</code> functions can be used to convert sorted trees to and from arrays. We can use <code>fromArray</code> to write an <code>Arbitrary</code> instance for trees:</p>
<pre><code class="language-haskell">instance arbTree :: (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>We can now use <code>Tree a</code> as the type of an argument to our test properties, whenever there is an <code>Arbitrary</code> instance available for the type <code>a</code>. For example, we can test that the <code>member</code> test always returns <code>true</code> after inserting a value:</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>Here, the argument <code>t</code> is a randomly-generated tree of type <code>Tree Int</code>, where the type argument disambiguated by the identity function <code>treeOfInt</code>.</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>(Medium) Create a newtype for <code>String</code> with an associated <code>Arbitrary</code> instance which generates collections of randomly-selected characters in the range <code>a-z</code>. <em>Hint</em>: use the <code>elements</code> and <code>arrayOf</code> functions from the <code>Test.QuickCheck.Gen</code> module.</li>
<li>(Difficult) Write a property which asserts that a value inserted into a tree is still a member of that tree after arbitrarily many more insertions.</li>
</ol>
<h2 id="testing-higher-order-functions"><a class="header" href="#testing-higher-order-functions">Testing Higher-Order Functions</a></h2>
<p>The <code>Merge</code> module defines another generalization of the <code>merge</code> function - the <code>mergeWith</code> function takes an additional function as an argument which is used to determine the order in which elements should be merged. That is, <code>mergeWith</code> is a higher-order function.</p>
<p>For example, we can pass the <code>length</code> function as the first argument, to merge two arrays which are already in length-increasing order. The result should also be in length-increasing order:</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>How might we test such a function? Ideally, we would like to generate values for all three arguments, including the first argument which is a function.</p>
<p>There is a second type class which allows us to create randomly-generated functions. It is called <code>Coarbitrary</code>, and it is defined as follows:</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p>The <code>coarbitrary</code> function takes a function argument of type <code>t</code>, and a random generator for a function result of type <code>r</code>, and uses the function argument to <em>perturb</em> the random generator. That is, it uses the function argument to modify the random output of the random generator for the result.</p>
<p>In addition, there is a type class instance which gives us <code>Arbitrary</code> functions if the function domain is <code>Coarbitrary</code> and the function codomain is <code>Arbitrary</code>:</p>
<pre><code class="language-haskell">instance arbFunction :: (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>In practice, this means that we can write properties which take functions as arguments. In the case of the <code>mergeWith</code> function, we can generate the first argument randomly, modifying our tests to take account of the new argument.</p>
<p>We cannot guarantee that the result will be sorted - we do not even necessarily have an <code>Ord</code> instance - but we can expect that the result be sorted with respect to the function <code>f</code> that we pass in as an argument. In addition, we need the two input arrays to be sorted with respect to <code>f</code>, so we use the <code>sortBy</code> function to sort <code>xs</code> and <code>ys</code> based on comparison after the function <code>f</code> has been applied:</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>Here, we use a function <code>intToBool</code> to disambiguate the type of the function <code>f</code>:</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>In addition to being <code>Arbitrary</code>, functions are also <code>Coarbitrary</code>:</p>
<pre><code class="language-haskell">instance coarbFunction :: (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>This means that we are not limited to just values and functions - we can also randomly generate <em>higher-order functions</em>, or functions whose arguments are higher-order functions, and so on.</p>
<h2 id="writing-coarbitrary-instances"><a class="header" href="#writing-coarbitrary-instances">Writing Coarbitrary Instances</a></h2>
<p>Just as we can write <code>Arbitrary</code> instances for our data types by using the <code>Monad</code> and <code>Applicative</code> instances of <code>Gen</code>, we can write our own <code>Coarbitrary</code> instances as well. This allows us to use our own data types as the domain of randomly-generated functions.</p>
<p>Let's write a <code>Coarbitrary</code> instance for our <code>Tree</code> type. We will need a <code>Coarbitrary</code> instance for the type of the elements stored in the branches:</p>
<pre><code class="language-haskell">instance coarbTree :: Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>We have to write a function which perturbs a random generator given a value of type <code>Tree a</code>. If the input value is a <code>Leaf</code>, then we will just return the generator unchanged:</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>If the tree is a <code>Branch</code>, then we will perturb the generator using the left subtree, the value, and the right subtree. We use function composition to create our perturbing function:</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>Now we are free to write properties whose arguments include functions taking trees as arguments. For example, the <code>Tree</code> module defines a function <code>anywhere</code>, which tests if a predicate holds on any subtree of its argument:</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>Now we are able to generate the predicate function randomly. For example, we expect the <code>anywhere</code> function to <em>respect disjunction</em>:</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>Here, the <code>treeOfInt</code> function is used to fix the type of values contained in the tree to the type <code>Int</code>:</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="testing-without-side-effects"><a class="header" href="#testing-without-side-effects">Testing Without Side-Effects</a></h2>
<p>For the purposes of testing, we usually include calls to the <code>quickCheck</code> function in the <code>main</code> action of our test suite. However, there is a variant of the <code>quickCheck</code> function, called <code>quickCheckPure</code> which does not use side-effects. Instead, it is a pure function which takes a random seed as an input, and returns an array of test results.</p>
<p>We can test <code>quickCheckPure</code> using PSCi. Here, we test that the <code>merge</code> operation is associative:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
… quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
…   ((xs `merge` ys) `merge` zs) ==
…     (xs `merge` (ys `merge` zs))
… ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code> takes three arguments: the random seed, the number of test cases to generate, and the property to test. If all tests pass, you should see an array of <code>Success</code> data constructors printed to the console.</p>
<p><code>quickCheckPure</code> might be useful in other situations, such as generating random input data for performance benchmarks, or generating sample form data for web applications.</p>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write <code>Coarbitrary</code> instances for the <code>Byte</code> and <code>Sorted</code> type constructors.</p>
</li>
<li>
<p>(Medium) Write a (higher-order) property which asserts associativity of the <code>mergeWith f</code> function for any function <code>f</code>. Test your property in PSCi using <code>quickCheckPure</code>.</p>
</li>
<li>
<p>(Medium) Write <code>Arbitrary</code> and <code>Coarbitrary</code> instances for the following data type:</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><em>Hint</em>: Use the <code>oneOf</code> function defined in <code>Test.QuickCheck.Gen</code> to define your <code>Arbitrary</code> instance.</p>
</li>
<li>
<p>(Medium) Use <code>all</code> to simplify the result of the <code>quickCheckPure</code> function - your new function should have type <code>List Result -&gt; Boolean</code> and should return <code>true</code> if every test passes and <code>false</code> otherwise.</p>
</li>
<li>
<p>(Medium) As another approach to simplifying the result of <code>quickCheckPure</code>, try writing a function <code>squashResults :: List Result -&gt; Result</code>. Consider using the <code>First</code> monoid from <code>Data.Maybe.First</code> with the <code>foldMap</code> function to preserve the first error in case of failure.</p>
</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we met the <code>quickcheck</code> package, which can be used to write tests in a declarative way using the paradigm of <em>generative testing</em>. In particular:</p>
<ul>
<li>We saw how to automate QuickCheck tests using <code>spago test</code>.</li>
<li>We saw how to write properties as functions, and how to use the <code>&lt;?&gt;</code> operator to improve error messages.</li>
<li>We saw how the <code>Arbitrary</code> and <code>Coarbitrary</code> type classes enable generation of boilerplate testing code, and how they allow us to test higher-order properties.</li>
<li>We saw how to implement custom <code>Arbitrary</code> and <code>Coarbitrary</code> instances for our own data types.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter12.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter14.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter12.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter14.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
