<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Monadic Adventures - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html" class="active"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="monadic-adventures"><a class="header" href="#monadic-adventures">Monadic Adventures</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>The goal of this chapter will be to learn about <em>monad transformers</em>, which provide a way to combine side-effects provided by different monads. The motivating example will be a text adventure game which can be played on the console in NodeJS. The various side-effects of the game (logging, state, and configuration) will all be provided by a monad transformer stack.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>This module's project introduces the following new dependencies:</p>
<ul>
<li><code>ordered-collections</code>, which provides data typs for immutable maps and sets</li>
<li><code>transformers</code>, which provides implementations of standard monad transformers</li>
<li><code>node-readline</code>, which provides FFI bindings to the <a href="https://nodejs.org/api/readline.html"><code>readline</code></a> interface provided by NodeJS</li>
<li><code>optparse</code>, which provides applicative parsers for processing command line arguments</li>
</ul>
<h2 id="how-to-play-the-game"><a class="header" href="#how-to-play-the-game">How To Play The Game</a></h2>
<p>To run the project, use <code>spago run</code></p>
<p>By default you will see a usage message:</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>To provide command line arguments, you can either call <code>spago run</code> with the <code>-a</code> option to pass additional arguments directly to your application, or you can call <code>spago bundle-app</code>, which will create an index.js file that can be run directly with <code>node</code>.<br />
For example, to provide the player name using the <code>-p</code> option:</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>From the prompt, you can enter commands like <code>look</code>, <code>inventory</code>, <code>take</code>, <code>use</code>, <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>. There is also a <code>debug</code> command, which can be used to print the game state when the <code>--debug</code> command line option is provided.</p>
<p>The game is played on a two-dimensional grid, and the player moves by issuing commands <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>. The game contains a collection of items which can either be in the player's possession (in the user's <em>inventory</em>), or on the game grid at some location. Items can be picked up by the player, using the <code>take</code> command.</p>
<p>For reference, here is a complete walkthrough of the game:</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>The game is very simple, but the aim of the chapter is to use the <code>transformers</code> package to build a library which will enable rapid development of this type of game.</p>
<h2 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad</a></h2>
<p>We will start by looking at some of the monads provided by the <code>transformers</code> package.</p>
<p>The first example is the <code>State</code> monad, which provides a way to model <em>mutable state</em> in pure code. We have already seen an approach to mutable state provided by the <code>Effect</code> monad. <code>State</code> provides an alternative.</p>
<p>The <code>State</code> type constructor takes two type parameters: the type <code>s</code> of the state, and the return type <code>a</code>. Even though we speak of the &quot;<code>State</code> monad&quot;, the instance of the <code>Monad</code> type class is actually provided for the <code>State s</code> type constructor, for any type <code>s</code>.</p>
<p>The <code>Control.Monad.State</code> module provides the following API:</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>Note that these API signatures are presented in a simplified form using the <code>State</code> type constructor for now. The actual API involves <code>MonadState</code> which we'll cover in the later &quot;Type Classes&quot; section of this chapter, so don't worry if you see different signatures in your IDE tooltips or on Pursuit.</p>
<p>Let's see an example. One use of the <code>State</code> monad might be to add the values in an array of integers to the current state. We could do that by choosing <code>Int</code> as the state type <code>s</code>, and using <code>traverse_</code> to traverse the array, with a call to <code>modify</code> for each array element:</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p>The <code>Control.Monad.State</code> module provides three functions for running a computation in the <code>State</code> monad:</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>Each of these functions takes an initial state of type <code>s</code> and a computation of type <code>State s a</code>. <code>evalState</code> only returns the return value, <code>execState</code> only returns the final state, and <code>runState</code> returns both, expressed as a value of type <code>Tuple a s</code>.</p>
<p>Given the <code>sumArray</code> function above, we could use <code>execState</code> in PSCi to sum the numbers in several arrays as follows:</p>
<pre><code class="language-text">&gt; :paste
… execState (do
…   sumArray [1, 2, 3]
…   sumArray [4, 5]
…   sumArray [6]) 0
… ^D
21
</code></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p>(Easy) What is the result of replacing <code>execState</code> with <code>runState</code> or <code>evalState</code> in our example above?</p>
</li>
<li>
<p>(Medium) A string of parentheses is <em>balanced</em> if it is obtained by either concatenating zero-or-more shorter balanced
strings, or by wrapping a shorter balanced string in a pair of parentheses.</p>
<p>Use the <code>State</code> monad and the <code>traverse_</code> function to write a function</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>which tests whether or not a <code>String</code> of parentheses is balanced, by keeping track of the number of opening parentheses
which have not been closed. Your function should work as follows:</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><em>Hint</em>: you may like to use the <code>toCharArray</code> function from the <code>Data.String.CodeUnits</code> module to turn the input string into an array of characters.</p>
</li>
</ol>
<h2 id="the-reader-monad"><a class="header" href="#the-reader-monad">The Reader Monad</a></h2>
<p>Another monad provided by the <code>transformers</code> package is the <code>Reader</code> monad. This monad provides the ability to read from a global configuration. Whereas the <code>State</code> monad provides the ability to read and write a single piece of mutable state, the <code>Reader</code> monad only provides the ability to read a single piece of data.</p>
<p>The <code>Reader</code> type constructor takes two type arguments: a type <code>r</code> which represents the configuration type, and the return type <code>a</code>.</p>
<p>The <code>Control.Monad.Reader</code> module provides the following API:</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p>The <code>ask</code> action can be used to read the current configuration, and the <code>local</code> action can be used to run a computation with a modified configuration.</p>
<p>For example, suppose we were developing an application controlled by permissions, and we wanted to use the <code>Reader</code> monad to hold the current user's permissions object. We might choose the type <code>r</code> to be some type <code>Permissions</code> with the following API:</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>Whenever we wanted to check if the user had a particular permission, we could use <code>ask</code> to retrieve the current permissions object. For example, only administrators might be allowed to create new users:</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p>To elevate the user's permissions, we might use the <code>local</code> action to modify the <code>Permissions</code> object during the execution of some computation:</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>Then we could write a function to create a new user, even if the user did not have the <code>admin</code> permission:</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p>To run a computation in the <code>Reader</code> monad, the <code>runReader</code> function can be used to provide the global configuration:</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<p>In these exercises, we will use the <code>Reader</code> monad to build a small library for rendering documents with indentation. The &quot;global configuration&quot; will be a number indicating the current indentation level:</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>(Easy) Write a function <code>line</code> which renders a function at the current indentation level. Your function should have the following type:</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><em>Hint</em>: use the <code>ask</code> function to read the current indentation level. The <code>power</code> function from <code>Data.Monoid</code> may be helpful too.</p>
</li>
<li>
<p>(Easy) Use the <code>local</code> function to write a function</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>which increases the indentation level for a block of code.</p>
</li>
<li>
<p>(Medium) Use the <code>sequence</code> function defined in <code>Data.Traversable</code> to write a function</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>which concatenates a collection of documents, separating them with new lines.</p>
</li>
<li>
<p>(Medium) Use the <code>runReader</code> function to write a function</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>which renders a document as a String.</p>
</li>
</ol>
<p>You should now be able to use your library to write simple documents, as follows:</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="the-writer-monad"><a class="header" href="#the-writer-monad">The Writer Monad</a></h2>
<p>The <code>Writer</code> monad provides the ability to accumulate a secondary value in addition to the return value of a computation.</p>
<p>A common use case is to accumulate a log of type <code>String</code> or <code>Array String</code>, but the <code>Writer</code> monad is more general than this. It can actually be used to accumulate a value in any monoid, so it might be used to keep track of an integer total using the <code>Additive Int</code> monoid, or to track whether any of several intermediate <code>Boolean</code> values were true, using the <code>Disj Boolean</code> monoid.</p>
<p>The <code>Writer</code> type constructor takes two type arguments: a type <code>w</code> which should be an instance of the <code>Monoid</code> type class, and the return type <code>a</code>.</p>
<p>The key element of the <code>Writer</code> API is the <code>tell</code> function:</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p>The <code>tell</code> action appends the provided value to the current accumulated result.</p>
<p>As an example, let's add a log to an existing function by using the <code>Array String</code> monoid. Consider our previous implementation of the <em>greatest common divisor</em> function:</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>We could add a log to this function by changing the return type to <code>Writer (Array String) Int</code>:</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>We only have to change our function slightly to log the two inputs at each step:</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p>We can run a computation in the <code>Writer</code> monad by using either of the <code>execWriter</code> or <code>runWriter</code> functions:</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>Just like in the case of the <code>State</code> monad, <code>execWriter</code> only returns the accumulated log, whereas <code>runWriter</code> returns both the log and the result.</p>
<p>We can test our modified function in PSCi:</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Rewrite the <code>sumArray</code> function above using the <code>Writer</code> monad and the <code>Additive Int</code> monoid from the <code>monoid</code> package.</p>
</li>
<li>
<p>(Medium) The <em>Collatz</em> function is defined on natural numbers <code>n</code> as <code>n / 2</code> when <code>n</code> is even, and <code>3 * n + 1</code> when <code>n</code> is odd. For example, the iterated Collatz sequence starting at <code>10</code> is as follows:</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>It is conjectured that the iterated Collatz sequence always reaches <code>1</code> after some finite number of applications of the Collatz function.</p>
<p>Write a function which uses recursion to calculate how many iterations of the Collatz function are required before the sequence reaches <code>1</code>.</p>
<p>Modify your function to use the <code>Writer</code> monad to log each application of the Collatz function.</p>
</li>
</ol>
<h2 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h2>
<p>Each of the three monads above: <code>State</code>, <code>Reader</code> and <code>Writer</code>, are also examples of so-called <em>monad transformers</em>. The equivalent monad transformers are called <code>StateT</code>, <code>ReaderT</code>, and <code>WriterT</code> respectively.</p>
<p>What is a monad transformer? Well, as we have seen, a monad augments PureScript code with some type of side effect, which can be interpreted in PureScript by using the appropriate handler (<code>runState</code>, <code>runReader</code>, <code>runWriter</code>, etc.) This is fine if we only need to use <em>one</em> side-effect. However, it is often useful to use more than one side-effect at once. For example, we might want to use <code>Reader</code> together with <code>Maybe</code> to express <em>optional results</em> in the context of some global configuration. Or we might want the mutable state provided by the <code>State</code> monad together with the pure error tracking capability of the <code>Either</code> monad. This is the problem solved by <em>monad transformers</em>.</p>
<p>Note that we have already seen that the <code>Effect</code> monad provides a partial solution to this problem. Monad transformers provide another solution, and each approach has its own benefits and limitations.</p>
<p>A monad transformer is a type constructor which is parameterized not only by a type, but by another type constructor. It takes one monad and turns it into another monad, adding its own variety of side-effects.</p>
<p>Let's see an example. The monad transformer version of the <code>State</code> monad is <code>StateT</code>, defined in the <code>Control.Monad.State.Trans</code> module. We can find the kind of <code>StateT</code> using PSCi:</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>This looks quite confusing, but we can apply <code>StateT</code> one argument at a time to understand how to use it.</p>
<p>The first type argument is the type of the state we wish to use, as was the case for <code>State</code>. Let's use a state of type <code>String</code>:</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>The next argument is a type constructor of kind <code>Type -&gt; Type</code>. It represents the underlying monad, which we want to add the effects of <code>StateT</code> to. For the sake of an example, let's choose the <code>Either String</code> monad:</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>We are left with a type constructor. The final argument represents the return type, and we might instantiate it to <code>Number</code> for example:</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>Finally we are left with something of kind <code>Type</code>, which means we can try to find values of this type.</p>
<p>The monad we have constructed - <code>StateT String (Either String)</code> - represents computations which can fail with an error, and which can use mutable state.</p>
<p>We can use the actions of the outer <code>StateT String</code> monad (<code>get</code>, <code>put</code>, and <code>modify</code>) directly, but in order to use the effects of the wrapped monad (<code>Either String</code>), we need to &quot;lift&quot; them over the monad transformer. The <code>Control.Monad.Trans</code> module defines the <code>MonadTrans</code> type class, which captures those type constructors which are monad transformers, as follows:</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>This class contains a single member, <code>lift</code>, which takes computations in any underlying monad <code>m</code> and lifts them into the wrapped monad <code>t m</code>. In our case, the type constructor <code>t</code> is <code>StateT String</code>, and <code>m</code> is the <code>Either String</code> monad, so <code>lift</code> provides a way to lift computations of type <code>Either String a</code> to computations of type <code>StateT String (Either String) a</code>. This means that we can use the effects of <code>StateT String</code> and <code>Either String</code> side-by-side, as long as we use <code>lift</code> every time we use a computation of type <code>Either String a</code>.</p>
<p>For example, the following computation reads the underlying state, and then throws an error if the state is the empty string:</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>If the state is not empty, the computation uses <code>put</code> to update the state to <code>drop 1 s</code> (that is, <code>s</code> with the first character removed), and returns <code>take 1 s</code> (that is, the first character of <code>s</code>).</p>
<p>Let's try this in PSCi:</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>This is not very remarkable, since we could have implemented this without <code>StateT</code>. However, since we are working in a monad, we can use do notation or applicative combinators to build larger computations from smaller ones. For example, we can apply <code>split</code> twice to read the first two characters from a string:</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p>We can use the <code>split</code> function with a handful of other actions to build a basic parsing library. In fact, this is the approach taken by the <code>parsing</code> library. This is the power of monad transformers - we can create custom-built monads for a variety of problems, choosing the side-effects that we need, and keeping the expressiveness of do notation and applicative combinators.</p>
<h2 id="the-exceptt-monad-transformer"><a class="header" href="#the-exceptt-monad-transformer">The ExceptT Monad Transformer</a></h2>
<p>The <code>transformers</code> package also defines the <code>ExceptT e</code> monad transformer, which is the transformer corresponding to the <code>Either e</code> monad. It provides the following API:</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance monadErrorExceptT :: Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p>The <code>MonadError</code> class captures those monads which support throwing and catching of errors of some type <code>e</code>, and an instance is provided for the <code>ExceptT e</code> monad transformer. The <code>throwError</code> action can be used to indicate failure, just like <code>Left</code> in the <code>Either e</code> monad. The <code>catchError</code> action allows us to continue after an error is thrown using <code>throwError</code>.</p>
<p>The <code>runExceptT</code> handler is used to run a computation of type <code>ExceptT e m a</code>.</p>
<p>This API is similar to that provided by the <code>exceptions</code> package and the <code>Exception</code> effect. However, there are some important differences:</p>
<ul>
<li><code>Exception</code> uses actual JavaScript exceptions, whereas <code>ExceptT</code> models errors as a pure data structure.</li>
<li>The <code>Exception</code> effect only supports exceptions of one type, namely JavaScript's <code>Error</code> type, whereas <code>ExceptT</code> supports errors of any type. In particular, we are free to define new error types.</li>
</ul>
<p>Let's try out <code>ExceptT</code> by using it to wrap the <code>Writer</code> monad. Again, we are free to use actions from the monad transformer <code>ExceptT e</code> directly, but computations in the <code>Writer</code> monad should be lifted using <code>lift</code>:</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>If we test this function in PSCi, we can see how the two effects of accumulating a log and throwing an error interact. First, we can run the outer <code>ExceptT</code> computation of type by using <code>runExceptT</code>, leaving a result of type <code>Writer (Array String) (Either String String)</code>. We can then use <code>runWriter</code> to run the inner <code>Writer</code> computation:</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>Note that only those log messages which were written before the error was thrown actually get appended to the log.</p>
<h2 id="monad-transformer-stacks"><a class="header" href="#monad-transformer-stacks">Monad Transformer Stacks</a></h2>
<p>As we have seen, monad transformers can be used to build new monads on top of existing monads. For some monad transformer <code>t1</code> and some monad <code>m</code>, the application <code>t1 m</code> is also a monad. That means that we can apply a <em>second</em> monad transformer <code>t2</code> to the result <code>t1 m</code> to construct a third monad <code>t2 (t1 m)</code>. In this way, we can construct a <em>stack</em> of monad transformers, which combine the side-effects provided by their constituent monads.</p>
<p>In practice, the underlying monad <code>m</code> is either the <code>Effect</code> monad, if native side-effects are required, or the <code>Identity</code> monad, defined in the <code>Data.Identity</code> module. The <code>Identity</code> monad adds no new side-effects, so transforming the <code>Identity</code> monad only provides the effects of the monad transformer. In fact, the <code>State</code>, <code>Reader</code> and <code>Writer</code> monads are implemented by transforming the <code>Identity</code> monad with <code>StateT</code>, <code>ReaderT</code> and <code>WriterT</code> respectively.</p>
<p>Let's see an example in which three side effects are combined. We will use the <code>StateT</code>, <code>WriterT</code> and <code>ExceptT</code> effects, with the <code>Identity</code> monad on the bottom of the stack. This monad transformer stack will provide the side effects of mutable state, accumulating a log, and pure errors.</p>
<p>We can use this monad transformer stack to reproduce our <code>split</code> action with the added feature of logging.</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>If we test this computation in PSCi, we see that the state is appended to the log for every invocation of <code>split</code>.</p>
<p>Note that we have to remove the side-effects in the order in which they appear in the monad transformer stack: first we use <code>runStateT</code> to remove the <code>StateT</code> type constructor, then <code>runWriterT</code>, then <code>runExceptT</code>. Finally, we run the computation in the <code>Identity</code> monad by using <code>unwrap</code>.</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>However, if the parse is unsuccessful because the state is empty, then no log is printed at all:</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>This is because of the way in which the side-effects provided by the <code>ExceptT</code> monad transformer interact with the side-effects provided by the <code>WriterT</code> monad transformer. We can address this by changing the order in which the monad transformer stack is composed. If we move the <code>ExceptT</code> transformer to the top of the stack, then the log will contain all messages written up until the first error, as we saw earlier when we transformed <code>Writer</code> with <code>ExceptT</code>.</p>
<p>One problem with this code is that we have to use the <code>lift</code> function multiple times to lift computations over multiple monad transformers: for example, the call to <code>throwError</code> has to be lifted twice, once over <code>WriterT</code> and a second time over <code>StateT</code>. This is fine for small monad transformer stacks, but quickly becomes inconvenient.</p>
<p>Fortunately, as we will see, we can use the automatic code generation provided by type class inference to do most of this &quot;heavy lifting&quot; for us.</p>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use the <code>ExceptT</code> monad transformer over the <code>Identity</code> functor to write a function <code>safeDivide</code> which divides two numbers, throwing an error (as the String &quot;Divide by zero!&quot;) if the denominator is zero.</p>
</li>
<li>
<p>(Medium) Write a parser</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>which matches a string as a prefix of the current state, or fails with an error message.</p>
<p>Your parser should work as follows:</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><em>Hint</em>: you can use the implementation of <code>split</code> as a starting point. You might find the <code>stripPrefix</code> function useful.</p>
</li>
<li>
<p>(Difficult) Use the <code>ReaderT</code> and <code>WriterT</code> monad transformers to reimplement the document printing library which we wrote earlier using the <code>Reader</code> monad.</p>
<p>Instead of using <code>line</code> to emit strings and <code>cat</code> to concatenate strings, use the <code>Array String</code> monoid with the <code>WriterT</code> monad transformer, and <code>tell</code> to append a line to the result. Use the same names as in the original implementation but ending with an apostrophe (<code>'</code>).</p>
</li>
</ol>
<h2 id="type-classes-to-the-rescue"><a class="header" href="#type-classes-to-the-rescue">Type Classes to the Rescue!</a></h2>
<p>When we looked at the <code>State</code> monad at the start of this chapter, I gave the following types for the actions of the <code>State</code> monad:</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>In reality, the types given in the <code>Control.Monad.State.Class</code> module are more general than this:</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p>The <code>Control.Monad.State.Class</code> module defines the <code>MonadState</code> (multi-parameter) type class, which allows us to abstract over &quot;monads which support pure mutable state&quot;. As one would expect, the <code>State s</code> type constructor is an instance of the <code>MonadState s</code> type class, but there are many more interesting instances of this class.</p>
<p>In particular, there are instances of <code>MonadState</code> for the <code>WriterT</code>, <code>ReaderT</code> and <code>ExceptT</code> monad transformers, provided in the <code>transformers</code> package. Each of these monad transformers has an instance for <code>MonadState</code> whenever the underlying <code>Monad</code> does. In practice, this means that as long as <code>StateT</code> appears <em>somewhere</em> in the monad transformer stack, and everything above <code>StateT</code> is an instance of <code>MonadState</code>, then we are free to use <code>get</code>, <code>put</code> and <code>modify</code> directly, without the need to use <code>lift</code>.</p>
<p>Indeed, the same is true of the actions we covered for the <code>ReaderT</code>, <code>WriterT</code>, and <code>ExceptT</code> transformers. <code>transformers</code> defines a type class for each of the major transformers, allowing us to abstract over monads which support their operations.</p>
<p>In the case of the <code>split</code> function above, the monad stack we constructed is an instance of each of the <code>MonadState</code>, <code>MonadWriter</code> and <code>MonadError</code> type classes. This means that we don't need to call <code>lift</code> at all! We can just use the actions <code>get</code>, <code>put</code>, <code>tell</code> and <code>throwError</code> as if they were defined on the monad stack itself:</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>This computation really looks like we have extended our programming language to support the three new side-effects of mutable state, logging and error handling. However, everything is still implemented using pure functions and immutable data under the hood.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>The <code>control</code> package defines a number of abstractions for working with computations which can fail. One of these is the <code>Alternative</code> type class:</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code> provides two new combinators: the <code>empty</code> value, which provides a prototype for a failing computation, and the <code>alt</code> function (and its alias, <code>&lt;|&gt;</code>) which provides the ability to fall back to an <em>alternative</em> computation in the case of an error.</p>
<p>The <code>Data.Array</code> module provides two useful functions for working with type constructors in the <code>Alternative</code> type class:</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p>There is also an equivalent <code>many</code> and <code>some</code> for <code>Data.List</code></p>
<p>The <code>many</code> combinator uses the <code>Alternative</code> type class to repeatedly run a computation <em>zero-or-more</em> times. The <code>some</code> combinator is similar, but requires at least the first computation to succeed.</p>
<p>In the case of our <code>Parser</code> monad transformer stack, there is an instance of <code>Alternative</code> induced by the <code>ExceptT</code> component, which supports failure by composing errors in different branches using a <code>Monoid</code> instance (this is why we chose <code>Array String</code> for our <code>Errors</code> type). This means that we can use the <code>many</code> and <code>some</code> functions to run a parser multiple times:</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>Here, the input string <code>&quot;test&quot;</code> has been repeatedly split to return an array of four single-character strings, the leftover state is empty, and the log shows that we applied the <code>split</code> combinator four times.</p>
<h2 id="monad-comprehensions"><a class="header" href="#monad-comprehensions">Monad Comprehensions</a></h2>
<p>The <code>Control.MonadPlus</code> module defines a subclass of the <code>Alternative</code> type class, called <code>MonadPlus</code>. <code>MonadPlus</code> captures those type constructors which are both monads and instances of <code>Alternative</code>:</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>In particular, our <code>Parser</code> monad is an instance of <code>MonadPlus</code>.</p>
<p>When we covered array comprehensions earlier in the book, we introduced the <code>guard</code> function, which could be used to filter out unwanted results. In fact, the <code>guard</code> function is more general, and can be used for any monad which is an instance of <code>MonadPlus</code>:</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>The <code>&lt;|&gt;</code> operator allows us to backtrack in case of failure. To see how this is useful, let's define a variant of the <code>split</code> combinator which only matches upper case characters:</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>Here, we use a <code>guard</code> to fail if the string is not upper case. Note that this code looks very similar to the array comprehensions we saw earlier - using <code>MonadPlus</code> in this way, we sometimes refer to constructing <em>monad comprehensions</em>.</p>
<h2 id="backtracking"><a class="header" href="#backtracking">Backtracking</a></h2>
<p>We can use the <code>&lt;|&gt;</code> operator to backtrack to another alternative in case of failure. To demonstrate this, let's define one more parser, which matches lower case characters:</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>With this, we can define a parser which eagerly matches many upper case characters if the first character is upper case, or many lower case character if the first character is lower case:</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>This parser will match characters until the case changes:</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p>We can even use <code>many</code> to fully split a string into its lower and upper case components:</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>Again, this illustrates the power of reusability that monad transformers bring - we were able to write a backtracking parser in a declarative style with only a few lines of code, by reusing standard abstractions!</p>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Remove the calls to the <code>lift</code> function from your implementation of the <code>string</code> parser. Verify that the new implementation type checks, and convince yourself that it should.</p>
</li>
<li>
<p>(Medium) Use your <code>string</code> parser with the <code>some</code> combinator to write a parser <code>asFollowedByBs</code> which recognizes strings consisting of several copies of the string <code>&quot;a&quot;</code> followed by several copies of the string <code>&quot;b&quot;</code>.</p>
</li>
<li>
<p>(Medium) Use the <code>&lt;|&gt;</code> operator to write a parser <code>asOrBs</code> which recognizes strings of the letters <code>a</code> or <code>b</code> in any order.</p>
</li>
<li>
<p>(Difficult) The <code>Parser</code> monad might also be defined as follows:</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>What effect does this change have on our parsing functions?</p>
</li>
</ol>
<h2 id="the-rws-monad"><a class="header" href="#the-rws-monad">The RWS Monad</a></h2>
<p>One particular combination of monad transformers is so common that it is provided as a single monad transformer in the <code>transformers</code> package. The <code>Reader</code>, <code>Writer</code> and <code>State</code> monads are combined into the <em>reader-writer-state</em> monad, or more simply the <code>RWS</code> monad. This monad has a corresponding monad transformer called the <code>RWST</code> monad transformer.</p>
<p>We will use the <code>RWS</code> monad to model the game logic for our text adventure game.</p>
<p>The <code>RWS</code> monad is defined in terms of three type parameters (in addition to its return type):</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>Notice that the <code>RWS</code> monad is defined in terms of its own monad transformer, by setting the base monad to <code>Identity</code> which provides no side-effects.</p>
<p>The first type parameter, <code>r</code>, represents the global configuration type. The second, <code>w</code>, represents the monoid which we will use to accumulate a log, and the third, <code>s</code> is the type of our mutable state.</p>
<p>In the case of our game, our global configuration is defined in a type called <code>GameEnvironment</code> in the <code>Data.GameEnvironment</code> module:</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>It defines the player name, and a flag which indicates whether or not the game is running in debug mode. These options will be set from the command line when we come to run our monad transformer.</p>
<p>The mutable state is defined in a type called <code>GameState</code> in the <code>Data.GameState</code> module:</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p>The <code>Coords</code> data type represents points on a two-dimensional grid, and the <code>GameItem</code> data type is an enumeration of the items in the game:</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p>The <code>GameState</code> type uses two new data structures: <code>Map</code> and <code>Set</code>, which represent sorted maps and sorted sets respectively. The <code>items</code> property is a mapping from coordinates of the game grid to sets of game items at that location. The <code>player</code> property stores the current coordinates of the player, and the <code>inventory</code> property stores a set of game items currently held by the player.</p>
<p>The <code>Map</code> and <code>Set</code> data structures are sorted by their keys, can be used with any key type in the <code>Ord</code> type class. This means that the keys in our data structures should be totally ordered.</p>
<p>We will see how the <code>Map</code> and <code>Set</code> structures are used as we write the actions for our game.</p>
<p>For our log, we will use the <code>List String</code> monoid. We can define a type synonym for our <code>Game</code> monad, implemented using <code>RWS</code>:</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="implementing-game-logic"><a class="header" href="#implementing-game-logic">Implementing Game Logic</a></h2>
<p>Our game is going to be built from simple actions defined in the <code>Game</code> monad, by reusing the actions from the <code>Reader</code>, <code>Writer</code> and <code>State</code> monads. At the top level of our application, we will run the pure computations in the <code>Game</code> monad, and use the <code>Effect</code> monad to turn the results into observable side-effects, such as printing text to the console.</p>
<p>One of the simplest actions in our game is the <code>has</code> action. This action tests whether the player's inventory contains a particular game item. It is defined as follows:</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>This function uses the <code>get</code> action defined in the <code>MonadState</code> type class to read the current game state, and then uses the <code>member</code> function defined in <code>Data.Set</code> to test whether the specified <code>GameItem</code> appears in the <code>Set</code> of inventory items.</p>
<p>Another action is the <code>pickUp</code> action. It adds a game item to the player's inventory if it appears in the current room. It uses actions from the <code>MonadWriter</code> and <code>MonadState</code> type classes. First of all, it reads the current game state:</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>Next, <code>pickUp</code> looks up the set of items in the current room. It does this by using the <code>lookup</code> function defined in <code>Data.Map</code>:</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p>The <code>lookup</code> function returns an optional result indicated by the <code>Maybe</code> type constructor. If the key does not appear in the map, the <code>lookup</code> function returns <code>Nothing</code>, otherwise it returns the corresponding value in the <code>Just</code> constructor.</p>
<p>We are interested in the case where the corresponding item set contains the specified game item. Again we can test this using the <code>member</code> function:</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>In this case, we can use <code>put</code> to update the game state, and <code>tell</code> to add a message to the log:</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>Note that there is no need to <code>lift</code> either of the two computations here, because there are appropriate instances for both <code>MonadState</code> and <code>MonadWriter</code> for our <code>Game</code> monad transformer stack.</p>
<p>The argument to <code>put</code> uses a record update to modify the game state's <code>items</code> and <code>inventory</code> fields. We use the <code>update</code> function from <code>Data.Map</code> which modifies a value at a particular key. In this case, we modify the set of items at the player's current location, using the <code>delete</code> function to remove the specified item from the set. <code>inventory</code> is also updated, using <code>insert</code> to add the new item to the player's inventory set.</p>
<p>Finally, the <code>pickUp</code> function handles the remaining cases, by notifying the user using <code>tell</code>:</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p>As an example of using the <code>Reader</code> monad, we can look at the code for the <code>debug</code> command. This command allows the user to inspect the game state at runtime if the game is running in debug mode:</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>Here, we use the <code>ask</code> action to read the game configuration. Again, note that we don't need to <code>lift</code> any computation, and we can use actions defined in the <code>MonadState</code>, <code>MonadReader</code> and <code>MonadWriter</code> type classes in the same do notation block.</p>
<p>If the <code>debugMode</code> flag is set, then the <code>tell</code> action is used to write the state to the log. Otherwise, an error message is added.</p>
<p>The remainder of the <code>Game</code> module defines a set of similar actions, each using only the actions defined by the <code>MonadState</code>, <code>MonadReader</code> and <code>MonadWriter</code> type classes.</p>
<h2 id="running-the-computation"><a class="header" href="#running-the-computation">Running the Computation</a></h2>
<p>Since our game logic runs in the <code>RWS</code> monad, it is necessary to run the computation in order to respond to the user's commands.</p>
<p>The front-end of our game is built using two packages: <code>optparse</code>, which provides applicative command line parsing, and <code>node-readline</code>, which wraps NodeJS' <code>readline</code> module, allowing us to write interactive console-based applications.</p>
<p>The interface to our game logic is provided by the function <code>game</code> in the <code>Game</code> module:</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>To run this computation, we pass a list of words entered by the user as an array of strings, and run the resulting <code>RWS</code> computation using <code>runRWS</code>:</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code> looks like a combination of <code>runReader</code>, <code>runWriter</code> and <code>runState</code>. It takes a global configuration and an initial state as an argument, and returns a data structure containing the log, the result and the final state.</p>
<p>The front-end of our application is defined by a function <code>runGame</code>, with the following type signature:</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>This function interacts with the user via the console (using the <code>node-readline</code> and <code>console</code> packages). <code>runGame</code> takes the game configuration as a function argument.</p>
<p>The <code>node-readline</code> package provides the <code>LineHandler</code> type, which represents actions in the <code>Effect</code> monad which handle user input from the terminal. Here is the corresponding API:</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p>The <code>Interface</code> type represents a handle for the console, and is passed as an argument to the functions which interact with it. An <code>Interface</code> can be created using the <code>createConsoleInterface</code> function:</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>The first step is to set the prompt at the console. We pass the <code>interface</code> handle, and provide the prompt string and indentation level:</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>In our case, we are interested in implementing the line handler function. Our line handler is defined using a helper function in a <code>let</code> declaration, as follows:</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p>The <code>let</code> binding is closed over both the game configuration, named <code>env</code>, and the console handle, named <code>interface</code>.</p>
<p>Our handler takes an additional first argument, the game state. This is required since we need to pass the game state to <code>runRWS</code> to run the game's logic.</p>
<p>The first thing this action does is to break the user input into words using the <code>split</code> function from the <code>Data.String</code> module. It then uses <code>runRWS</code> to run the <code>game</code> action (in the <code>RWS</code> monad), passing the game environment and current game state.</p>
<p>Having run the game logic, which is a pure computation, we need to print any log messages to the screen and show the user a prompt for the next command. The <code>for_</code> action is used to traverse the log (of type <code>List String</code>) and print its entries to the console. Finally, <code>setLineHandler</code> is used to update the line handler function to use the updated game state, and the prompt is displayed again using the <code>prompt</code> action.</p>
<p>The <code>runGame</code> function finally attaches the initial line handler to the console interface, and displays the initial prompt:</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Implement a new command <code>cheat</code>, which moves all game items from the game grid into the user's inventory. Create a function <code>cheat :: Game Unit</code> in the <code>Game</code> module, and use this function from <code>game</code>.</p>
</li>
<li>
<p>(Difficult) The <code>Writer</code> component of the <code>RWS</code> monad is currently used for two types of messages: error messages and informational messages. Because of this, several parts of the code use case statements to handle error cases.</p>
<p>Refactor the code to use the <code>ExceptT</code> monad transformer to handle the error messages, and <code>RWS</code> to handle informational messages. <em>Note:</em> There are no tests for this exercise.</p>
</li>
</ol>
<h2 id="handling-command-line-options"><a class="header" href="#handling-command-line-options">Handling Command Line Options</a></h2>
<p>The final piece of the application is responsible for parsing command line options and creating the <code>GameEnvironment</code> configuration record. For this, we use the <code>optparse</code> package.</p>
<p><code>optparse</code> is an example of <em>applicative command line option parsing</em>. Recall that an applicative functor allows us to lift functions of arbitrary arity over a type constructor representing some type of side-effect. In the case of the <code>optparse</code> package, the functor we are interested in is the <code>Parser</code> functor (imported from the optparse module <code>Options.Applicative</code>, not to be confused with our <code>Parser</code> that we defined in the <code>Split</code> module), which adds the side-effect of reading from command line options. It provides the following handler:</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a
</code></pre>
<p>This is best illustrated by example. The application's <code>main</code> function is defined using <code>customExecParser</code> as follows:</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>The first argument is used to configure the <code>optparse</code> library. In our case, we simply configure it to show the help message when the application is run without any arguments (instead of showing a &quot;missing argument&quot; error) by using <code>OP.prefs OP.showHelpOnEmpty</code>, but the <code>Options.Applicative.Builder</code> module provides several other options.</p>
<p>The second argument is the complete description of our parser program:</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>Here <code>OP.info</code> combines a <code>Parser</code> with a set of options for how the help message is formatted. <code>env &lt;**&gt; OP.helper</code> takes any command line argument <code>Parser</code> named <code>env</code> and adds a <code>--help</code> option to it automatically. Options for the help message are of type <code>InfoMod</code>, which is a monoid, so we can use the <code>fold</code> function to add several options together. </p>
<p>The interesting part of our parser is constructing the <code>GameEnvironment</code>:</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code> and <code>debug</code> are both <code>Parser</code>s, so we can use our applicative operators <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to lift our <code>gameEnvironment</code> function, which has the type <code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code> over <code>Parser</code>. <code>OP.strOption</code> constructs a command line option that expects a string value, and is configured via a collection of <code>Mod</code>s folded together. <code>OP.flag</code> works similarly, but doesn't expect an associated value. <code>optparse</code> offers extensive <a href="https://pursuit.purescript.org/packages/purescript-optparse">documentation</a> on different modifiers available to build various command line parsers.</p>
<p>Notice how we were able to use the notation afforded by the applicative operators to give a compact, declarative specification of our command line interface. In addition, it is simple to add new command line arguments, simply by adding a new function argument to <code>runGame</code>, and then using <code>&lt;*&gt;</code> to lift <code>runGame</code> over an additional argument in the definition of <code>env</code>.</p>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>(Medium) Add a new Boolean-valued property <code>cheatMode</code> to the <code>GameEnvironment</code> record. Add a new command line flag <code>-c</code> to the <code>optparse</code> configuration which enables cheat mode. The <code>cheat</code> command from the previous exercise should be disallowed if cheat mode is not enabled.</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This chapter was a practical demonstration of the techniques we've learned so far, using monad transformers to build a pure specification of our game, and the <code>Effect</code> monad to build a front-end using the console.</p>
<p>Because we separated our implementation from the user interface, it would be possible to create other front-ends for our game. For example, we could use the <code>Effect</code> monad to render the game in the browser using the Canvas API or the DOM.</p>
<p>We have seen how monad transformers allow us to write safe code in an imperative style, where effects are tracked by the type system. In addition, type classes provide a powerful way to abstract over the actions provided by a monad, enabling code reuse. We were able to use standard abstractions like <code>Alternative</code> and <code>MonadPlus</code> to build useful monads by combining standard monad transformers.</p>
<p>Monad transformers are an excellent demonstration of the sort of expressive code that can be written by relying on advanced type system features such as higher-kinded polymorphism and multi-parameter type classes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter10.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter12.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter10.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter12.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
