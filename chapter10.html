<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Foreign Function Interface - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html" class="active"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-foreign-function-interface"><a class="header" href="#the-foreign-function-interface">The Foreign Function Interface</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>This chapter will introduce PureScript's <em>foreign function interface</em> (or <em>FFI</em>), which enables communication from PureScript code to JavaScript code, and vice versa. We will cover how to:</p>
<ul>
<li>Call pure, effectful, and asynchronous JavaScript functions from PureScript.</li>
<li>Work with untyped data.</li>
<li>Encode and parse JSON using the <code>argonaut</code> package.</li>
</ul>
<p>Towards the end of this chapter, we will revisit our recurring address book example. The goal of the chapter will be to add the following new functionality to our application using the FFI:</p>
<ul>
<li>Alert the user with a popup notification.</li>
<li>Store the serialized form data in the browser's local storage, and reload it when the application restarts.</li>
</ul>
<p>There is also an addendum which covers some additional topics which are not as commonly sought-after. Feel free to read these sections, but don't let them stand in the way of progressing through the remainder of the book if they're less relevant to your learning objectives:</p>
<ul>
<li>Understand the representation of PureScript values at runtime.</li>
<li>Call PureScript functions from JavaScript.</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The source code for this module is a continuation of the source code from chapters 3, 7 and 8. As such, the source tree includes the appropriate source files from those chapters.</p>
<p>This chapter introduces the <code>argonaut</code> library as a dependency. This library is used for encoding and decoding JSON.</p>
<p>The exercises for this chapter should be written in <code>test/MySolutions.purs</code> and can be checked against the unit tests in <code>test/Main.purs</code> by running <code>spago test</code>.</p>
<p>The Address Book app can be launched with <code>parcel src/index.html --open</code>. It uses the same workflow from Chapter 8, so refer to that chapter for more detailed instructions.</p>
<h2 id="a-disclaimer"><a class="header" href="#a-disclaimer">A Disclaimer</a></h2>
<p>PureScript provides a straightforward foreign function interface to make working with JavaScript as simple as possible. However, it should be noted that the FFI is an <em>advanced</em> feature of the language. To use it safely and effectively, you should have an understanding of the runtime representation of the data you plan to work with. This chapter aims to impart such an understanding as pertains to code in PureScript's standard libraries.</p>
<p>PureScript's FFI is designed to be very flexible. In practice, this means that developers have a choice, between giving their foreign functions very simple types, or using the type system to protect against accidental misuses of foreign code. Code in the standard libraries tends to favor the latter approach.</p>
<p>As a simple example, a JavaScript function makes no guarantees that its return value will not be <code>null</code>. Indeed, idiomatic JavaScript code returns <code>null</code> quite frequently! However, PureScript's types are usually not inhabited by a null value. Therefore, it is the responsibility of the developer to handle these corner cases appropriately when designing their interfaces to JavaScript code using the FFI.</p>
<h2 id="calling-javascript-from-purescript"><a class="header" href="#calling-javascript-from-purescript">Calling JavaScript From PureScript</a></h2>
<p>The simplest way to use JavaScript code from PureScript is to give a type to an existing JavaScript value using a <em>foreign import</em> declaration. Foreign import declarations must have a corresponding JavaScript declaration <em>exported</em> from a <em>foreign JavaScript module</em>.</p>
<p>For example, consider the <code>encodeURIComponent</code> function, which can be used in JavaScript to encode a component of a URI by escaping special characters:</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p>This function has the correct runtime representation for the function type <code>String -&gt; String</code>, since it takes non-null strings to non-null strings, and has no other side-effects.</p>
<p>We can assign this type to the function with the following foreign import declaration:</p>
<pre><code class="language-haskell">module Test.URI where

foreign import encodeURIComponent :: String -&gt; String
</code></pre>
<p>We also need to write a foreign JavaScript module to import it from. A corresponding foreign JavaScript module is one of the same name but extension changed from <code>.purs</code> to <code>.js</code>. If the Purescript module above is saved as <code>URI.purs</code>, then the foreign JavaScript module is saved as <code>URI.js</code>:</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

exports.encodeURIComponent = encodeURIComponent;
</code></pre>
<p>Purescript uses the CommonJS module system when interoperating with JavaScript. In CommonJS, functions and values are exported from a module by assigning them to <em>properties</em> of the <code>exports</code> object.</p>
<p>With these two pieces in place, we can now use the <code>encodeURIComponent</code> function from PureScript like any function written in PureScript. For example, in PSCi, we can reproduce the calculation above:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>We can also define our own functions in foreign modules. Here's an example of how to create and call a custom JavaScript function that squares a <code>Number</code>:</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

exports.square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="functions-of-multiple-arguments"><a class="header" href="#functions-of-multiple-arguments">Functions of Multiple Arguments</a></h2>
<p>Let's rewrite our <code>diagonal</code> function from Chapter 2 in a foreign module. This function calculates the diagonal of a right-angled triangle.</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>Recall that functions in PureScript are <em>curried</em>. <code>diagonal</code> is a function that takes a <code>Number</code> and returns a <em>function</em>, that takes a <code>Number</code> and returns a <code>Number</code>.</p>
<pre><code class="language-js">exports.diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>Or with ES6 arrow syntax (see ES6 note below).</p>
<pre><code class="language-js">exports.diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="uncurried-functions"><a class="header" href="#uncurried-functions">Uncurried Functions</a></h2>
<p>Writing curried functions in JavaScript isn't always feasible, despite being scarcely idiomatic. A typical multi-argument JavaScript function would be of the <em>uncurried</em> form:</p>
<pre><code class="language-js">exports.diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>The module <code>Data.Function.Uncurried</code> exports <em>wrapper</em> types and utility functions to work with uncurried functions.</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>Inspecting the type constructor <code>Fn2</code>:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code> takes three type arguments. <code>Fn2 a b c</code> is a type representing an uncurried function of two arguments of types <code>a</code> and <code>b</code>, that returns a value of type <code>c</code>. We used it to import <code>diagonalUncurried</code> from the foreign module.</p>
<p>We can then call it with <code>runFn2</code> which takes the uncurried function then the arguments.</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p>The <code>functions</code> package defines similar type constructors for function arities from 0 to 10.</p>
<h2 id="a-note-about-uncurried-functions"><a class="header" href="#a-note-about-uncurried-functions">A Note About Uncurried Functions</a></h2>
<p>PureScript's curried functions has certain advantages. It allows us to partially apply functions, and to give type class instances for function types - but it comes with a performance penalty. For performance critical code, it is sometimes necessary to define uncurried JavaScript functions which accept multiple arguments.</p>
<p>We can also create uncurried functions from PureScript. For a function of two arguments, we can use the <code>mkFn2</code> function.</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>We can apply the uncurried function of two arguments by using <code>runFn2</code> as before:</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>The key here is that the compiler <em>inlines</em> the <code>mkFn2</code> and <code>runFn2</code> functions whenever they are fully applied. The result is that the generated code is very compact:</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>For contrast, here is a traditional curried function:</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>and the resulting generated code, which is less compact due to the nested functions:</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="a-note-about-modern-javascript-syntax"><a class="header" href="#a-note-about-modern-javascript-syntax">A Note About Modern JavaScript Syntax</a></h2>
<p>The arrow function syntax we saw earlier is an ES6 feature, and so it is incompatible with some older browsers (namely IE11). As of writing, it is <a href="https://caniuse.com/#feat=arrow-functions">estimated that arrow functions are unavailable for the 6% of users</a> who have not yet updated their web browser.</p>
<p>In order to be compatible with the most users, the JavaScript code generated by the PureScript compiler does not use arrow functions. It is also recommended to <strong>avoid arrow functions in public libraries</strong> for the same reason.</p>
<p>You may still use arrow functions in your own FFI code, but then should include a tool such as <a href="https://github.com/babel/babel#intro">Babel</a> in your deployment workflow to convert these back to ES5 compatible functions.</p>
<p>If you find arrow functions in ES6 more readable, you may transform JavaScript code in the compiler's <code>output</code> directory with a tool like <a href="https://github.com/lebab/lebab">Lebab</a>:</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>This operation would convert the above <code>curriedAdd</code> function to:</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>The remaining examples in this book will use arrow functions instead of nested functions.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>(Medium) Write a JavaScript function <code>volumeFn</code> in the <code>Test.MySolutions</code> module that finds the volume of a box. Use an <code>Fn</code> wrapper from <code>Data.Function.Uncurried</code>.</li>
<li>(Medium) Rewrite <code>volumeFn</code> with arrow functions as <code>volumeArrow</code>.</li>
</ol>
<h2 id="passing-simple-types"><a class="header" href="#passing-simple-types">Passing Simple Types</a></h2>
<p>The following data types may be passed between PureScript and JavaScript as-is:</p>
<table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
<p>We've already seen examples with the primitive types <code>String</code> and <code>Number</code>. We'll now take a look at the structural types <code>Array</code> and <code>Record</code> (<code>Object</code> in JavaScript).</p>
<p>To demonstrate passing <code>Array</code>s, here's how to call a JavaScript function which takes an <code>Array</code> of <code>Int</code> and returns the cumulative sum as another array. Recall that, since JavaScript does not have a separate type for <code>Int</code>, both <code>Int</code> and <code>Number</code> in PureScript translate to <code>Number</code> in JavaScript.</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">exports.cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p>To demonstrate passing <code>Records</code>, here's how to call a JavaScript function which takes two <code>Complex</code> numbers as records, and returns their sum as another record. Note that a <code>Record</code> in PureScript is represented as an <code>Object</code> in JavaScript:</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">exports.addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>Note that the above techniques require trusting that JavaScript will return the expected types, as PureScript is not able to apply type checking to JavaScript code. We will describe this type safety concern in more detail later on in the JSON section, as well as cover techniques to protect against type mismatches.</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>(Medium) Write a JavaScript function <code>cumulativeSumsComplex</code> (and corresponding PureScript foreign import) that takes an <code>Array</code> of <code>Complex</code> numbers and returns the cumulative sum as another array of complex numbers.</li>
</ol>
<h2 id="beyond-simple-types"><a class="header" href="#beyond-simple-types">Beyond Simple Types</a></h2>
<p>We have seen examples of how to send and receive types with a native JavaScript representation, such as <code>String</code>, <code>Number</code>, <code>Array</code>, and <code>Record</code>, over FFI. Now we'll cover how to use some of the other types available in PureScript, like <code>Maybe</code>.</p>
<p>Suppose we wanted to recreate the <code>head</code> function on arrays by using a foreign declaration. In JavaScript, we might write the function as follows:</p>
<pre><code class="language-javascript">exports.head = arr =&gt;
  arr[0];
</code></pre>
<p>How would we type this function? We might try to give it the type <code>forall a. Array a -&gt; a</code>, but for empty arrays, this function returns <code>undefined</code>. Therefore, the type <code>forall a. Array a -&gt; a</code> does not correctly represent this implementation.</p>
<p>We instead want to return a <code>Maybe</code> value to handle this corner case:</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>But how do we return a <code>Maybe</code>? It is tempting to write the following:</p>
<pre><code class="language-js">// Don't do this

let Data_Maybe = require(&quot;../Data.Maybe&quot;)

exports.maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>Importing and using the <code>Data.Maybe</code> module directly in the foreign module isn't recommended as it makes our code brittle to changes in the code generator — <code>create</code> and <code>value</code> are not public APIs. Additionally, doing this can cause problems when using <code>purs bundle</code> for dead code elimination.</p>
<p>The recommended approach is to add extra parameters to our FFI-defined function to accept the functions we need.</p>
<pre><code class="language-js">exports.maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>Note that we wrote:</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>and not:</p>
<pre><code class="language-hs">forall a. ( a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>While both forms work, the latter is more vulnerable to unwanted inputs in place of <code>Just</code> and <code>Nothing</code>.
For example, in the more vulnerable case we could call it as follows:</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>which returns <code>Just 1000</code> for any array input.
This vulnerability is allowed because <code>(\_ -&gt; Just 1000)</code> and <code>Just 1000</code> match the signatures of <code>(a -&gt; Maybe a)</code> and <code>Maybe a</code> respectively when <code>a</code> is <code>Int</code> (based on input array).</p>
<p>In the more secure type signature, even when <code>a</code> is determined to be <code>Int</code> based on the input array, we still need to provide valid functions matching the signatures involving <code>forall x</code>.
The <em>only</em> option for <code>(forall x. Maybe x)</code> is <code>Nothing</code>, since a <code>Just</code> value would assume a type for <code>x</code> and will no longer be valid for all <code>x</code>. The only options for <code>(forall x. x -&gt; Maybe x)</code> are <code>Just</code> (our desired argument) and <code>(\_ -&gt; Nothing)</code>, which is the only remaining vulnerability.</p>
<h2 id="defining-foreign-types"><a class="header" href="#defining-foreign-types">Defining Foreign Types</a></h2>
<p>Suppose instead of returning a <code>Maybe a</code>, we want to actually return <code>arr[0]</code>. We want a type that represents a value either of type <code>a</code> or the <code>undefined</code> value (but not <code>null</code>). We'll call this type <code>Undefined a</code>.</p>
<p>We can define a <em>foreign type</em> using a <em>foreign type declaration</em>. The syntax is similar to defining a foreign function:</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>The <code>data</code> keyword here indicates that we are defining a <em>type</em>, not a value. Instead of a type signature, we give the <em>kind</em> of the new type. In this case, we declare the kind of <code>Undefined</code> to be <code>Type -&gt; Type</code>. In other words, <code>Undefined</code> is a type constructor.</p>
<p>We can now simply reuse our original definition for <code>head</code>:</p>
<pre><code class="language-javascript">exports.undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>And in the PureScript module:</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p>The body of the <code>undefinedHead</code> function returns <code>arr[0]</code> which may be <code>undefined</code>, and the type signature correctly reflects that fact.</p>
<p>This function has the correct runtime representation for its type, but is quite useless since we have no way to use a value of type <code>Undefined a</code>. Well, not exactly. We can use this type in another FFI!</p>
<p>We can write a function that will tell us whether a value is undefined or not:</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>This is defined in our foreign JavaScript module as follows:</p>
<pre><code class="language-javascript">exports.isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>We can now use <code>isUndefined</code> and <code>undefinedHead</code> together from PureScript to define a useful function:</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>Here, the foreign function we defined is very simple, which means we can benefit from the use of PureScript's typechecker as much as possible. This is good practice in general: foreign functions should be kept as small as possible, and application logic moved into PureScript code wherever possible.</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>Another option is to simply throw an exception in the case of an empty array. Strictly speaking, pure functions should not throw exceptions, but we have the flexibility to do so. We indicate the lack of safety in the function name:</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>In our foreign JavaScript module, we can define <code>unsafeHead</code> as follows:</p>
<pre><code class="language-javascript">exports.unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Given a record that represents a quadratic polynomial <code>a*x^2 + b*x + c = 0</code>:</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>Write a JavaScript function <code>quadraticRootsImpl</code> and a wrapper <code>quadraticRoots :: Quadratic -&gt; Pair Complex</code> that uses the quadratic formula to find the roots of this polynomial. Return the two roots as a <code>Pair</code> of <code>Complex</code> numbers. <em>Hint:</em> Use the <code>quadraticRoots</code> wrapper to pass a constructor for <code>Pair</code> to <code>quadraticRootsImpl</code>.</p>
</li>
<li>
<p>(Medium) Write the function <code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>. This function converts <code>undefined</code> to <code>Nothing</code> and <code>a</code> values to <code>Just</code>s.</p>
</li>
<li>
<p>(Difficult) With <code>toMaybe</code> in place, we can rewrite <code>maybeHead</code> as</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>Is this a better approach than our previous implementation? <em>Note:</em> There is no unit test for this exercise.</p>
</li>
</ol>
<h2 id="using-type-class-member-functions"><a class="header" href="#using-type-class-member-functions">Using Type Class Member Functions</a></h2>
<p>Just like our earlier guide on passing the <code>Maybe</code> constructor over FFI, this is another case of writing PureScript that calls JavaScript, which in turn calls PureScript functions again. Here we will explore how to pass type class member functions over the FFI.</p>
<p>We start with writing a foreign JavaScript function which expects the appropriate instance of <code>show</code> to match the type of <code>x</code>.</p>
<pre><code class="language-js">exports.boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>Then we write the matching signature:</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>and a wrapper function that passes the correct instance of <code>show</code>:</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>Alternatively in point-free form:</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>We can then call the wrapper:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>Here's another example demonstrating passing multiple functions, including a function of multiple arguments (<code>eq</code>):</p>
<pre><code class="language-js">exports.showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="effectful-functions"><a class="header" href="#effectful-functions">Effectful Functions</a></h2>
<p>Let's extend our <code>bold</code> function to log to the console. Logging is an <code>Effect</code>, and <code>Effect</code>s are represented in JavaScript as a function of zero arguments, <code>()</code> with arrow notation:</p>
<pre><code class="language-js">exports.yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>The new foreign import is the same as before, except that the return type changed from <code>String</code> to <code>Effect Unit</code>.</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>When testing this in the repl, notice that the string is printed directly to the console (instead of being quoted) and a <code>unit</code> value is returned.</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p>There are also <code>EffectFn</code> wrappers from <code>Effect.Uncurried</code>. These are similar to the <code>Fn</code> wrappers from <code>Data.Function.Uncurried</code> that we've already seen. These wrappers let you call uncurried effectful functions in PureScript.</p>
<p>You'd generally only use these if you want to call existing JavaScript library APIs directly, rather than wrapping those APIs in curried functions. So it doesn't make much sense to present an example of uncurried <code>yell</code>, where the JavaScript relies on PureScript type class members, since you wouldn't find that in the existing JavaScript ecosystem.</p>
<p>Instead, we'll modify our previous <code>diagonal</code> example to include logging in addition to returning the result:</p>
<pre><code class="language-js">exports.diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="asynchronous-functions"><a class="header" href="#asynchronous-functions">Asynchronous Functions</a></h2>
<p>Promises in JavaScript translate directly to asynchronous effects in PureScript with the help of the <code>aff-promise</code> library. See that library's <a href="https://pursuit.purescript.org/packages/purescript-aff-promise">documentation</a> for more information. We'll just go through a few examples.</p>
<p>Suppose we want to use this JavaScript <code>wait</code> promise (or asynchronous function) in our PureScript project. It may be used to delay execution for <code>ms</code> milliseconds.</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>We just need to export it wrapped as an <code>Effect</code> (function of zero arguments):</p>
<pre><code class="language-js">exports.sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>Then import it as follows:</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>We can then run this <code>Promise</code> in an <code>Aff</code> block like so:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
… launchAff_ do
…   log &quot;waiting&quot;
…   sleep 300
…   log &quot;done waiting&quot;
…
waiting
unit
done waiting
</code></pre>
<p>Note that asynchronous logging in the repl just waits to print until the entire block has finished executing. This code behaves more predictably when run with <code>spago test</code> where there is a slight delay <em>between</em> prints.</p>
<p>Let's look at another example where we return a value from a promise. This function is written with <code>async</code> and <code>await</code>, which is just syntactic sugar for promises.</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

exports.diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p>Since we're returning a <code>Number</code>, we represent this type in the <code>Promise</code> and <code>Aff</code> wrappers:</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
… launchAff_ do
…   res &lt;- diagonalAsync 300 3.0 4.0
…   logShow res
…
unit
5.0
</code></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<p>Exercises for the above sections are still on the ToDo list. If you have any ideas for good exercises, please make a suggestion.</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>There are many reasons to use JSON in an application, for example, it's a common means of communicating with web APIs. This section will discuss other use-cases too, beginning with a technique to improve type safety when passing structural data over the FFI.</p>
<p>Let's revisit our earlier FFI functions <code>cumulativeSums</code> and <code>addComplex</code> and introduce a bug to each:</p>
<pre><code class="language-js">exports.cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

exports.addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>We can use the original type signatures, and the code will still compile, despite the fact that the return types are incorrect.</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>We can even execute the code, which might either produce unexpected results or a runtime error:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>For example, our resulting <code>sums</code> is no-longer a valid <code>Array Int</code>, now that a <code>String</code> is included in the Array. And further operations produce unexpected behavior, rather than an outright error, as the <code>sum</code> of these <code>sums</code> is <code>0</code> rather than <code>10</code>. This could be a difficult bug to track down!</p>
<p>Likewise, there are no errors when calling <code>addComplexBroken</code>; however, accessing the <code>imag</code> field of our <code>Complex</code> result will either produce unexpected behavior (returning <code>NaN</code> instead of <code>7.0</code>), or a non-obvious runtime error.</p>
<p>Let's use JSON to make our PureScript code more impervious to bugs in JavaScript code.</p>
<p>The <code>argonaut</code> library contains the JSON decoding and encoding capabilities we need. That library has excellent <a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">documentation</a>, so we will only cover basic usage in this book.</p>
<p>If we create an alternate foreign import that defines the return type as <code>Json</code>:</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>Note that we're simply pointing to our existing broken functions:</p>
<pre><code class="language-js">exports.cumulativeSumsJson = exports.cumulativeSumsBroken
exports.addComplexJson = exports.addComplexBroken
</code></pre>
<p>And then write a wrapper to decode the returned foreign <code>Json</code> value:</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>Then any values that can't be successfully decoded to our return type appear as a <code>Left</code> error <code>String</code>:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>If we call the working versions, a <code>Right</code> value is returned.</p>
<p>Try this yourself by modifying <code>test/Examples.js</code> with the following change to point to the working versions before running the next repl block.</p>
<pre><code class="language-js">exports.cumulativeSumsJson = exports.cumulativeSums
exports.addComplexJson = exports.addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>Using JSON is also the easiest way to pass other structural types, such as <code>Map</code> and <code>Set</code> through the FFI. Note that since JSON only consists of booleans, numbers, strings, arrays, and objects of other JSON values, we can't write a <code>Map</code> and <code>Set</code> directly in JSON. But we can represent these structures as arrays (assuming the keys and values can also be represented in JSON), and then decode them back to <code>Map</code> or <code>Set</code>.</p>
<p>Here's an example of a foreign function signature that modifies a <code>Map</code> of <code>String</code> keys and <code>Int</code> values, along with the wrapper function that handles JSON encoding and decoding.</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Note that this is a prime use case for function composition. Both of these alternatives are equivalent to the above:</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Here is the JavaScript implementation. Note the <code>Array.from</code> step which is necessary to convert the JavaScript <code>Map</code> into a JSON-friendly format before decoding converts it back to a PureScript <code>Map</code>.</p>
<pre><code class="language-js">exports.mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>Now we can send and receive a <code>Map</code> over the FFI:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Write a JavaScript function and PureScript wrapper <code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code> that returns a <code>Set</code> of all the values in a <code>Map</code>. <em>Hint</em>: The <code>.values()</code> instance method for Map may be useful in your JavaScript code.</p>
</li>
<li>
<p>(Easy) Write a new wrapper for the previous JavaScript function with the signature <code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code> so it works with a wider variety of maps. Note that you'll need to add some type class constraints for <code>k</code> and <code>v</code>. The compiler will guide you.</p>
</li>
<li>
<p>(Medium) Rewrite the earlier <code>quadraticRoots</code> function as <code>quadraticRootsSet</code> which returns the <code>Complex</code> roots as a <code>Set</code> via JSON (instead of as a <code>Pair</code>).</p>
</li>
<li>
<p>(Difficult) Rewrite the earlier <code>quadraticRoots</code> function as <code>quadraticRootsSafe</code> which uses JSON to pass the <code>Pair</code> of <code>Complex</code> roots over FFI. Don't use the <code>Pair</code> constructor in JavaScript, but instead, just return the pair in a decoder-compatible format.
<em>Hint</em>: You'll need to write a <code>DecodeJson</code> instance for <code>Pair</code>. Consult the <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonaut docs</a> for instruction on writing your own decode instance. Their <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a> instance may also be a helpful reference.  Note that you'll need a <code>newtype</code> wrapper for <code>Pair</code> to avoid creating an &quot;orphan instance&quot;.</p>
</li>
<li>
<p>(Medium) Write a <code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code> function to parse and decode a JSON string containing a 2D array, such as <code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>. <em>Hint</em>: You'll need to use <code>jsonParser</code> to convert the <code>String</code> into <code>Json</code> before decoding.</p>
</li>
<li>
<p>(Medium) The following data type represents a binary tree with values at the leaves:</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>Derive generic <code>EncodeJson</code> and <code>DecodeJson</code> instances for the <code>Tree</code> type.
Consult the <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonaut docs</a> for instructions on how to do this.
Note that you'll also need generic instances of <code>Show</code> and <code>Eq</code> to enable unit testing for this exercise, but those should be straightforward to implement after tackling the JSON instances.</p>
</li>
<li>
<p>(Difficult) The following <code>data</code> type should be represented directly in JSON as either an integer or a string:</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>Write instances of <code>EncodeJson</code> and <code>DecodeJson</code> for the <code>IntOrString</code> data type which implement this behavior. <em>Hint</em>: The <code>alt</code> operator from <code>Control.Alt</code> may be helpful.</p>
</li>
</ol>
<h2 id="address-book"><a class="header" href="#address-book">Address book</a></h2>
<p>In this section we will apply our newly-acquired FFI and JSON knowledge to build on our address book example from chapter 8. We will add the following features:</p>
<ul>
<li>A Save button at the bottom of the form that, when clicked, serializes the state of the form to JSON and saves it in local storage.</li>
<li>Automatic retrieval of the JSON document from local storage upon page reload. The form fields are populated with the contents of this document.</li>
<li>A pop-up alert if there is an issue saving or loading the form state.</li>
</ul>
<p>We'll start by creating FFI wrappers for the following Web Storage APIs in our <code>Effect.Storage</code> module:</p>
<ul>
<li><code>setItem</code> takes a key and a value (both strings), and returns a computation which stores (or updates) the value in local storage at the specified key.</li>
<li><code>getItem</code> takes a key, and attempts to retrieve the associated value from local storage. However, since the <code>getItem</code> method on <code>window.localStorage</code> can return <code>null</code>, the return type is not <code>String</code>, but <code>Json</code>.</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>Here is the corresponding JavaScript implementation of these functions in <code>Effect/Storage.js</code>:</p>
<pre><code class="language-js">exports.setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

exports.getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>We'll create a save button like so:</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>And write our validated <code>person</code> as a JSON string with <code>setItem</code> in the <code>validateAndSave</code> function:</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>Note that if we attempt to compile at this stage, we'll encounter the following error:</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>This is because <code>PhoneType</code> in the <code>Person</code> record needs an <code>EncodeJson</code> instance. We'll just derive a generic encode instance, and a decode instance too while we're at it. More information how this works is available in the argonaut docs:</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance genericPhoneType :: Generic PhoneType _

instance encodeJsonPhoneType :: EncodeJson PhoneType where encodeJson = genericEncodeJson
instance decodeJsonPhoneType :: DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>Now we can save our <code>person</code> to local storage, but this isn't very useful unless we can retrieve the data. We'll tackle that next.</p>
<p>We'll start with retrieving the &quot;person&quot; string from local storage:</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>Then we'll create a helper function to handle converting the string from local storage to our <code>Person</code> record. Note that this string in storage may be <code>null</code>, so we represent it as a foreign <code>Json</code> until it is successfully decoded as a <code>String</code>. There are a number of other conversion steps along the way - each of which return an <code>Either</code> value, so it makes sense to organize these together in a <code>do</code> block.</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>Then we inspect this result to see if it succeeded. If it failed, we'll log the errors and use our default <code>examplePerson</code>, otherwise we'll use the person retrieved from local storage.</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>Finally, we'll pass this <code>initialPerson</code> to our component via the <code>props</code> record:</p>
<pre><code class="language-hs">-- Create JSX node from react component.
app = element addressBookApp { initialPerson }
</code></pre>
<p>And pick it up on the other side to use in our state hook:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>As a finishing touch, we'll improve the quality of our error messages by appending to the <code>String</code> of each <code>Left</code> value with <code>lmap</code>.</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>Only the first error should ever occur during normal operation of this app. You can trigger the other errors by opening your web browser's dev tools, editing the saved &quot;person&quot; string in local storage, and refreshing the page. How you modify the JSON string determines which error is triggered. See if you can trigger each of them.</p>
<p>That covers local storage. Next we'll implement the <code>alert</code> action, which is very similar to the <code>log</code> action from the <code>Effect.Console</code> module. The only difference is that the <code>alert</code> action uses the <code>window.alert</code> method, whereas the <code>log</code> action uses the <code>console.log</code> method. As such, <code>alert</code> can only be used in environments where <code>window.alert</code> is defined, such as a web browser.</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">exports.alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>We want this alert to appear when either:</p>
<ul>
<li>A user attempts to save a form with validation errors.</li>
<li>The state cannot be retrieved from local storage.</li>
</ul>
<p>That is accomplished by simply replacing <code>log</code> with <code>alert</code> on these lines:</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>(Easy) Write a wrapper for the <code>removeItem</code> method on the <code>localStorage</code> object, and add your foreign function to the <code>Effect.Storage</code> module.</li>
<li>(Medium) Add a &quot;Reset&quot; button that, when clicked, calls the newly-created <code>removeItem</code> function to delete the &quot;person&quot; entry from local storage.</li>
<li>(Easy) Write a wrapper for the <code>confirm</code> method on the JavaScript <code>Window</code> object, and add your foreign function to the <code>Effect.Alert</code> module.</li>
<li>(Medium) Call this <code>confirm</code> function when a users clicks the &quot;Reset&quot; button to ask if they're sure they want to reset their address book.</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we've learned how to work with foreign JavaScript code from PureScript and we've seen the issues involved with writing trustworthy code using the FFI:</p>
<ul>
<li>We've seen the importance of ensuring that foreign functions have correct representations.</li>
<li>We learned how to deal with corner cases like null values and other types of JavaScript data, by using foreign types, or the <code>Json</code> data type.</li>
<li>We saw how to safely serialize and deserialize JSON data.</li>
</ul>
<p>For more examples, the <code>purescript</code>, <code>purescript-contrib</code> and <code>purescript-node</code> GitHub organizations provide plenty of examples of libraries which use the FFI. In the remaining chapters, we will see some of these libraries put to use to solve real-world problems in a type-safe way.</p>
<h1 id="addendum"><a class="header" href="#addendum">Addendum</a></h1>
<h2 id="calling-purescript-from-javascript"><a class="header" href="#calling-purescript-from-javascript">Calling PureScript from JavaScript</a></h2>
<p>Calling a PureScript function from JavaScript is very simple, at least for functions with simple types.</p>
<p>Let's take the following simple module as an example:</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>This function finds the greatest common divisor of two numbers by repeated subtraction. It is a nice example of a case where you might like to use PureScript to define the function, but have a requirement to call it from JavaScript: it is simple to define this function in PureScript using pattern matching and recursion, and the implementor can benefit from the use of the type checker.</p>
<p>To understand how this function can be called from JavaScript, it is important to realize that PureScript functions always get turned into JavaScript functions of a single argument, so we need to apply its arguments one-by-one:</p>
<pre><code class="language-javascript">var Test = require('Test');
Test.gcd(15)(20);
</code></pre>
<p>Here, I am assuming that the code was compiled with <code>spago build</code>, which compiles PureScript modules to CommonJS modules. For that reason, I was able to reference the <code>gcd</code> function on the <code>Test</code> object, after importing the <code>Test</code> module using <code>require</code>.</p>
<p>You might also like to bundle JavaScript code for the browser, using <code>spago bundle-app --to file.js</code>. In that case, you would access the <code>Test</code> module from the global PureScript namespace, which defaults to <code>PS</code>:</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h2 id="understanding-name-generation"><a class="header" href="#understanding-name-generation">Understanding Name Generation</a></h2>
<p>PureScript aims to preserve names during code generation as much as possible. In particular, most identifiers which are neither PureScript nor JavaScript keywords can be expected to be preserved, at least for names of top-level declarations.</p>
<p>If you decide to use a JavaScript keyword as an identifier, the name will be escaped with a double dollar symbol. For example,</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>In addition, if you would like to use special characters in your identifier names, they will be escaped using a single dollar symbol. For example,</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>Where compiled PureScript code is intended to be called from JavaScript, it is recommended that identifiers only use alphanumeric characters, and avoid JavaScript keywords. If user-defined operators are provided for use in PureScript code, it is good practice to provide an alternative function with an alphanumeric name for use in JavaScript.</p>
<h2 id="runtime-data-representation"><a class="header" href="#runtime-data-representation">Runtime Data Representation</a></h2>
<p>Types allow us to reason at compile-time that our programs are &quot;correct&quot; in some sense - that is, they will not break at runtime. But what does that mean? In PureScript, it means that the type of an expression should be compatible with its representation at runtime.</p>
<p>For that reason, it is important to understand the representation of data at runtime to be able to use PureScript and JavaScript code together effectively. This means that for any given PureScript expression, we should be able to understand the behavior of the value it will evaluate to at runtime.</p>
<p>The good news is that PureScript expressions have particularly simple representations at runtime. It should always be possible to understand the runtime data representation of an expression by considering its type.</p>
<p>For simple types, the correspondence is almost trivial. For example, if an expression has the type <code>Boolean</code>, then its value <code>v</code> at runtime should satisfy <code>typeof v === 'boolean'</code>. That is, expressions of type <code>Boolean</code> evaluate to one of the (JavaScript) values <code>true</code> or <code>false</code>. In particular, there is no PureScript expression of type <code>Boolean</code> which evaluates to <code>null</code> or <code>undefined</code>.</p>
<p>A similar law holds for expressions of type <code>Int</code> <code>Number</code> and <code>String</code> - expressions of type <code>Int</code> or <code>Number</code> evaluate to non-null JavaScript numbers, and expressions of type <code>String</code> evaluate to non-null JavaScript strings. Expressions of type <code>Int</code> will evaluate to integers at runtime, even though they cannot not be distinguished from values of type <code>Number</code> by using <code>typeof</code>.</p>
<p>What about <code>Unit</code>? Well, since <code>Unit</code> has only one inhabitant (<code>unit</code>) and its value is not observable, it doesn't actually matter what it's represented with at runtime. Old code tends to represent it using <code>{}</code>. Newer code, however, tends to use <code>undefined</code>. So, although it doesn't really matter what you use to represent <code>Unit</code>, it is recommended to use <code>undefined</code> (not returning anything from a function also returns <code>undefined</code>).</p>
<p>What about some more complex types?</p>
<p>As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression <code>f</code> has type <code>a -&gt; b</code> for some types <code>a</code> and <code>b</code>, and an expression <code>x</code> evaluates to a value with the correct runtime representation for type <code>a</code>, then <code>f</code> evaluates to a JavaScript function, which when applied to the result of evaluating <code>x</code>, has the correct runtime representation for type <code>b</code>. As a simple example, an expression of type <code>String -&gt; String</code> evaluates to a function which takes non-null JavaScript strings to non-null JavaScript strings.</p>
<p>As you might expect, PureScript's arrays correspond to JavaScript arrays. But remember - PureScript arrays are homogeneous, so every element has the same type. Concretely, if a PureScript expression <code>e</code> has type <code>Array a</code> for some type <code>a</code>, then <code>e</code> evaluates to a (non-null) JavaScript array, all of whose elements have the correct runtime representation for type <code>a</code>.</p>
<p>We've already seen that PureScript's records evaluate to JavaScript objects. Just as for functions and arrays, we can reason about the runtime representation of data in a record's fields by considering the types associated with its labels. Of course, the fields of a record are not required to be of the same type.</p>
<h2 id="representing-adts"><a class="header" href="#representing-adts">Representing ADTs</a></h2>
<p>For every constructor of an algebraic data type, the PureScript compiler creates a new JavaScript object type by defining a function. Its constructors correspond to functions which create new JavaScript objects based on those prototypes.</p>
<p>For example, consider the following simple ADT:</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>The PureScript compiler generates the following code:</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>Here, we see two JavaScript object types: <code>Zero</code> and <code>One</code>. It is possible to create values of each type by using JavaScript's <code>new</code> keyword. For constructors with arguments, the compiler stores the associated data in fields called <code>value0</code>, <code>value1</code>, etc.</p>
<p>The PureScript compiler also generates helper functions. For constructors with no arguments, the compiler generates a <code>value</code> property, which can be reused instead of using the <code>new</code> operator repeatedly. For constructors with one or more arguments, the compiler generates a <code>create</code> function, which takes arguments with the appropriate representation and applies the appropriate constructor.</p>
<p>What about constructors with more than one argument? In that case, the PureScript compiler also creates a new object type, and a helper function. This time, however, the helper function is curried function of two arguments. For example, this algebraic data type:</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>generates this JavaScript code:</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>Here, values of the object type <code>Two</code> can be created using the <code>new</code> keyword, or by using the <code>Two.create</code> function.</p>
<p>The case of newtypes is slightly different. Recall that a newtype is like an algebraic data type, restricted to having a single constructor taking a single argument. In this case, the runtime representation of the newtype is actually the same as the type of its argument.</p>
<p>For example, this newtype representing telephone numbers:</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>is actually represented as a JavaScript string at runtime. This is useful for designing libraries, since newtypes provide an additional layer of type safety, but without the runtime overhead of another function call.</p>
<h2 id="representing-quantified-types"><a class="header" href="#representing-quantified-types">Representing Quantified Types</a></h2>
<p>Expressions with quantified (polymorphic) types have restrictive representations at runtime. In practice, this means that there are relatively few expressions with a given quantified type, but that we can reason about them quite effectively.</p>
<p>Consider this polymorphic type, for example:</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>What sort of functions have this type? Well, there is certainly one function with this type - namely, the <code>identity</code> function, defined in the <code>Prelude</code>:</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>In fact, the <code>identity</code> function is the <em>only</em> (total) function with this type! This certainly seems to be the case (try writing an expression with this type which is not observably equivalent to <code>identity</code>), but how can we be sure? We can be sure by considering the runtime representation of the type.</p>
<p>What is the runtime representation of a quantified type <code>forall a. t</code>? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type <code>t</code> for any choice of type <code>a</code>. In our example above, a function of type <code>forall a. a -&gt; a</code> must have the correct runtime representation for the types <code>String -&gt; String</code>, <code>Number -&gt; Number</code>, <code>Array Boolean -&gt; Array Boolean</code>, and so on. It must take strings to strings, numbers to numbers, etc.</p>
<p>But that is not enough - the runtime representation of a quantified type is more strict than this. We require any expression to be <em>parametrically polymorphic</em> - that is, it cannot use any information about the type of its argument in its implementation. This additional condition prevents problematic implementations such as the following JavaScript function from inhabiting a polymorphic type:</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>Certainly, this function takes strings to strings, numbers to numbers, etc. but it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged, and so <code>identity</code> is indeed the only inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>A full discussion of <em>parametric polymorphism</em> and <em>parametricity</em> is beyond the scope of this book. Note however, that since PureScript's types are <em>erased</em> at runtime, a polymorphic function in PureScript <em>cannot</em> inspect the runtime representation of its arguments (without using the FFI), and so this representation of polymorphic data is appropriate.</p>
<h2 id="representing-constrained-types"><a class="header" href="#representing-constrained-types">Representing Constrained Types</a></h2>
<p>Functions with a type class constraint have an interesting representation at runtime. Because the behavior of the function might depend on the type class instance chosen by the compiler, the function is given an additional argument, called a <em>type class dictionary</em>, which contains the implementation of the type class functions provided by the chosen instance.</p>
<p>For example, here is a simple PureScript function with a constrained type which uses the <code>Show</code> type class:</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>The generated JavaScript looks like this:</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p>Notice that <code>shout</code> is compiled to a (curried) function of two arguments, not one. The first argument <code>dict</code> is the type class dictionary for the <code>Show</code> constraint. <code>dict</code> contains the implementation of the <code>show</code> function for the type <code>a</code>.</p>
<p>We can call this function from JavaScript by passing an explicit type class dictionary from <code>Data.Show</code> as the first parameter:</p>
<pre><code class="language-javascript">shout(require('Data.Show').showNumber)(42);
</code></pre>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>
<p>(Easy) What are the runtime representations of these types?</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>What can you say about the expressions which have these types?</p>
</li>
<li>
<p>(Medium) Try using the functions defined in the <code>arrays</code> package, calling them from JavaScript, by compiling the library using <code>spago build</code> and importing modules using the <code>require</code> function in NodeJS. <em>Hint</em>: you may need to configure the output path so that the generated CommonJS modules are available on the NodeJS module path.</p>
</li>
</ol>
<h2 id="representing-side-effects"><a class="header" href="#representing-side-effects">Representing Side Effects</a></h2>
<p>The <code>Effect</code> monad is also defined as a foreign type. Its runtime representation is quite simple - an expression of type <code>Effect a</code> should evaluate to a JavaScript function of <strong>no arguments</strong>, which performs any side-effects and returns a value with the correct runtime representation for type <code>a</code>.</p>
<p>The definition of the <code>Effect</code> type constructor is given in the <code>Effect</code> module as follows:</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>As a simple example, consider the <code>random</code> function defined in the <code>random</code> package. Recall that its type was:</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p>The definition of the <code>random</code> function is given here:</p>
<pre><code class="language-javascript">exports.random = Math.random;
</code></pre>
<p>Notice that the <code>random</code> function is represented at runtime as a function of no arguments. It performs the side effect of generating a random number, and returns it, and the return value matches the runtime representation of the <code>Number</code> type: it is a non-null JavaScript number.</p>
<p>As a slightly more interesting example, consider the <code>log</code> function defined by the <code>Effect.Console</code> module in the <code>console</code> package. The <code>log</code> function has the following type:</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>And here is its definition:</p>
<pre><code class="language-javascript">exports.log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>The representation of <code>log</code> at runtime is a JavaScript function of a single argument, returning a function of no arguments. The inner function performs the side-effect of writing a message to the console.</p>
<p>Expressions of type <code>Effect a</code> can be invoked from JavaScript like regular JavaScript methods. For example, since the <code>main</code> function is required to have type <code>Effect a</code> for some type <code>a</code>, it can be invoked as follows:</p>
<pre><code class="language-javascript">require('Main').main();
</code></pre>
<p>When using <code>spago bundle-app --to</code> or <code>spago run</code>, this call to <code>main</code> is generated automatically, whenever the <code>Main</code> module is defined.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter9.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter9.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
